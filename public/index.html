<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBH Only Connect</title>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: url('/images/BBH22-background.jpg') center center / cover repeat fixed;
            padding: 2rem;
        }

        .game-container {
            max-width: 64rem;
            margin: 0 auto;
        }

        .header-card {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title { 
            font-size: 1.875rem; 
            font-weight: bold; 
            color: white;
        }

        .header-title.has-buzzer {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .buzzed-indicator {
            display: inline-block;
            color: #fbbf24;
            font-size: 1.5rem;
            font-weight: 700;
            padding: 0.75rem 2rem;
            background: rgba(30, 30, 30, 0.7);
            border: 2px solid rgba(251, 191, 36, 0.6);
            border-radius: 0.5rem;
            animation: pulseGlow 1s ease-in-out infinite;
            text-align: center;
            min-width: 200px;
        }

        @keyframes pulseGlow {
            0%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.8);
                background: rgba(30, 30, 30, 0.7);
            }
            50% {
                opacity: 0.9;
                text-shadow: 0 0 20px rgba(251, 191, 36, 1);
                background: rgba(30, 30, 30, 0.8);
            }
        }

        .category-display {
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
        }

        .score-box {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            min-width: 150px;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .score-value {
            color: white;
            font-size: 3rem;
            font-weight: bold;
            line-height: 1;
        }

        .round-selector {
            display: grid;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .round-btn {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:hover {
            background: rgba(30, 30, 30, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .round-title {
            font-size: 0.875rem;
            opacity: 0.8;
            margin-bottom: 0.25rem;
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .question-btn {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:hover {
            background: rgba(30, 30, 30, 0.25);
            transform: scale(1.05);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:active {
            transform: scale(1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn.completed {
            background: rgba(100, 100, 120, 0.4);
            border-color: rgba(100, 100, 120, 0.6);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .question-btn.completed:hover {
            transform: none;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .clue-container {
            background: transparent;
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .buttons-container {
            background: transparent;
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
            height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .buttons-container.player-hidden {
            display: none;
        }

        .timer-bar-container {
            height: 30px;
            background: #7f1d1d;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 0.5rem;
            position: relative;
            box-shadow: 0 5px 8px rgba(0, 0, 0, 0.4), 
                        inset 0 3px 0 rgba(0, 0, 0, 0.4),
                        inset 0 -2px 0 rgba(255, 255, 255, 0.2);
        }

        .timer-bar {
            height: 100%;
            background: #d1d5db;
            transition: width 0.1s linear;
            margin-left: auto;
            border-radius: 0;
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .points-label {
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            margin-bottom: 0.25rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .clue-wrapper {
            display: flex;
            flex-direction: column;
            min-height: 160px;
        }

        .timer-spacer {
            height: 60px;
            margin-bottom: 0rem;
        }

        .clue-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .clue-btn {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            border-radius: 0.5rem;
            padding: 2rem 1rem;
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:hover:not(.revealed):not(.disabled) {
            background: rgba(30, 30, 30, 0.3);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:active:not(.revealed):not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn.revealed {
            background: rgba(59, 130, 246, 0.4);
            border-color: #3b82f6;
            cursor: default;
        }

        .clue-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .answer-box {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);;
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            height: 80px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 1.5rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .button-row {
            display: flex;
            gap: 1rem;
        }

        .btn {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-correct {
            background: #22c55e;
            color: white;
        }

        .btn-correct:hover:not(.disabled) {
            background: #16a34a;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-incorrect {
            background: #ef4444;
            color: white;
        }

        .btn-incorrect:hover:not(.disabled) {
            background: #dc2626;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover:not(.disabled) {
            background: #2563eb;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 1.5rem;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:hover:not(.disabled) {
            background: rgba(30, 30, 30, 0.25);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:active:not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Connecting Wall Styles */
        .wall-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
            position: relative;
            min-height: 440px;
        }

        .wall-tile {
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(80, 80, 80, 1);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
            cursor: pointer;
            transition: top 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                        left 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        background 0.3s ease,
                        border-color 0.3s ease,
                        transform 0.2s ease,
                        align-items 0.3s ease,
                        padding-top 0.3s ease;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            position: absolute;
        }

        .wall-tile.text-up {
            align-items: flex-start;
            padding-top: 1.5rem;
        }

        .wall-tile:hover:not(.solved):not(.locked):not(.disabled) {
            transform: scale(1.05);
        }

        .wall-tile.selected {
            background: rgba(59, 130, 246, 0.6);
            border-color: rgba(59, 130, 246, 0.9);
            transform: scale(1.05);
        }

        .wall-tile.solved {
            cursor: default;
            pointer-events: none;
        }

        .wall-tile.locked {
            cursor: not-allowed;
        }

        .wall-tile.hidden-text {
            color: transparent;
        }

        .wall-tile.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .wall-tile.group-0 {
            background: rgba(250, 204, 21, 0.55);
            border-color: rgba(250, 204, 21, 0.95);
        }

        .wall-tile.group-1 {
            background: rgba(34, 197, 94, 0.55);
            border-color: rgba(34, 197, 94, 0.95);
        }

        .wall-tile.group-2 {
            background: rgba(59, 130, 246, 0.55);
            border-color: rgba(59, 130, 246, 0.95);
        }

        .wall-tile.group-3 {
            background: rgba(168, 85, 247, 0.55);
            border-color: rgba(168, 85, 247, 0.95);
        }

        .connection-display {
            position: absolute;
            left: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
            color: white;
            font-size: 0.875rem;
            font-weight: bold;
            z-index: 10;
            width: calc(100% - 4px);
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
        }

        .connection-display.fade-in {
            animation: fadeIn 1s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .time-up-modal, .wall-frozen-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .time-up-content, .wall-frozen-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        .time-up-title, .wall-frozen-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .guess-btn {
            width: 45px;
            height: 45px;
            border-radius: 0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .guess-btn.correct {
            background: rgba(34, 197, 94, 0.5);
            border-color: rgba(34, 197, 94, 0.8);
            color: white;
        }

        .guess-btn.incorrect {
            background: rgba(239, 68, 68, 0.5);
            border-color: rgba(239, 68, 68, 0.8);
            color: white;
        }

        .guess-btn:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .guess-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .wall-timer-container {
            margin-top: 1rem;
            transition: opacity 0.5s ease;
        }

        .wall-timer-container.fade-out {
            opacity: 0;
        }

        .wall-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .lives-display {
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
        }

        /* Missing Vowels Styles */
        .vowels-category-box {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: bold;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .vowels-category-box:hover:not(.disabled) {
            background: rgba(30, 30, 30, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-category-box.disabled {
            cursor: not-allowed;
        }

        .vowels-category-box.disabled:hover {
            transform: none;
            background: rgba(30, 30, 30, 0.15);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-clue-box {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 3rem;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-clue-text {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0;
            letter-spacing: normal;
        }

        .vowels-letter {
            display: inline-block;
            transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .vowels-letter.spread {
            letter-spacing: normal;
        }

        .vowels-letter.vowel {
            opacity: 0;
            transform: scale(0);
        }

        .vowels-letter.vowel.revealed {
            opacity: 1;
            transform: scale(1);
        }

        /* Final Score Screen */
        .final-score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
        }

        .final-score-names {
            color: white;
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }

        .final-score-box {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 3rem 5rem;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .final-score-value {
            color: white;
            font-size: 6rem;
            font-weight: bold;
            line-height: 1;
        }

        .end-session-btn {
            margin-top: 2rem;
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid rgba(80, 80, 80, 1);
            color: white;
            padding: 1rem 3rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.25rem;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn:hover:not(.disabled) {
            background: rgba(30, 30, 30, 0.25);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn:active:not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Setup Modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .setup-modal-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
            min-width: 400px;
        }

        .setup-modal-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .setup-input {
            width: 100%;
            padding: 1rem;
            font-size: 1.25rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 1.5rem;
            outline: none;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .setup-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .setup-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .setup-btn {
            background: #3b82f6;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .setup-btn:hover {
            background: #2563eb;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .setup-btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .error-message {
            color: #ef4444;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            min-height: 1.5rem;
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <script>
        // Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyDFwH8lQwlOysP_6DNFgXuDJCvbPg0Jhz0",
          authDomain: "bbh-only-connect.firebaseapp.com",
          databaseURL: "https://bbh-only-connect-default-rtdb.firebaseio.com",
          projectId: "bbh-only-connect",
          storageBucket: "bbh-only-connect.firebasestorage.app",
          messagingSenderId: "845745689572",
          appId: "1:845745689572:web:c75fe89aac465af7942df1"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const sessionId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        
        // Game data
        const gameData = {
            exampleRound1: { clues: ["Ashley Keenan", "Carl Landon Clark", "Mitchell Stokes", "Josh Consalvo"], connection: "BBH Production Members", points: [0, 0, 0, 0] },
            round1: [
                { clues: ["To celebrate<br>John Paul II's visit<br>-L", "In the world of<br>BoJack Horseman<br>-D", "After 26 years<br>-LAND", "To promote the<br>2028 Olympics<br>+OOO"], connection: "HOLLYWOOD Sign Alterations", points: [5, 3, 2, 1] },
                { clues: ["1", "Group 1", "1.0079", "H"], connection: "Identifiers of Hydrogen on the Table of Elements", points: [5, 3, 2, 1] },
                { clues: ["EditGrid<br>Team and Concepts", "Airtable<br>Airtable", "Numbers<br>Apple", "Sheets<br>Google"], connection: "Variations of Excel & Their Company", points: [5, 3, 2, 1] },
                { clues: ["Aconcagua", "Denali/<br>McKinley", "Kilimanjaro", "Mount Everest"], connection: "Seven Summits / Highest Continent Peaks", points: [5, 3, 2, 1] },
                { clues: ["Happy Women", "Anarchy & Chaos", "The Running Alive", "Repairing Good"], connection: "TV Show Title Opposites", points: [5, 3, 2, 1] },
                { clues: [
                    {
                        type: "audio",
                        youtube: "5Q_q9cq3B5A",
                        title: "Wheels On The Bus<br>Melanie Martinez",
                        start: 9,
                        duration: 30
                    },
                    {
                        type: "audio",
                        youtube: "xt0V0_1MS0Q",
                        title: "Bicycle Race<br>Queen",
                        start: 31,
                        duration: 30
                    },
                    {
                        type: "audio",
                        youtube: "A0F9lh8TiSM",
                        title: "Midnight Train To Georgia<br>Gladys Knight",
                        start: 15,
                        duration: 30
                    },
                    {
                        type: "audio",
                        youtube: "GemKqzILV4w",
                        title: "Chasing Cars<br>Snow Patrol",
                        start: 2,
                        duration: 30
                    },
                ],
                 connection: "Modes of Transportation",
                 points: [5, 3, 2, 1]
                },
            ],
            exampleRound2: { clues: ["Mercury", "Earth", "Jupiter", "Uranus"], answer: "Uranus", sequence: "Every Other Planet", points: [0, 0, 0] },
            round2: [
                { clues: ["4:<br>McKinley Speedway Crash", "3:<br>Devil's Roller Coaster Crash", "2:<br>Route 23 Pile-Up", "1:<br>Flight 180 Explosion"], answer: "1:<br>Flight 180 Explosion", sequence: "Final Destination Opening Disasters", points: [5, 3, 2] },
                { clues: ["We Are", "Harry's House", "Midnights", "Cowboy Carter"], answer: "Carter", sequence: "Most Recent Albums of the Year (GRAMMYs)", points: [5, 3, 2] },
                { clues: ["Humpty<br>Again", "Humpty<br>Men", "All<br>Fall", "Couldn't<br>Wall"], answer: "Couldn't<br>Wall", sequence: "Beginning --> & Final <-- Words of Humpty Dumpty Lines", points: [5, 3, 2] },
                { clues: ["Tina Wesson", "Danni Boatwright", "Sophie Clarke", "Michele Fitzgerald"], answer: "Michele Fitzgerald", sequence: "First Female Survivor Winner In Each Decade", points: [5, 3, 2] },
                { clues: ["1/4<br>Oklahoma City or<br>San Antonio, for example", "2/4<br>Cincinnati or<br>Kansas City, for example", "3/4<br>Seattle or<br>Tampa Bay, for example", "4/4<br>Chicago or<br>Los Angeles, for example"], answer: "4/4<br>Chicago or<br>Los Angeles, for example", sequence: "Big 4 Sports per city, gaining more", points: [5, 3, 2] },
                { clues: [
                    {
                        type: "audio",
                        youtube: "SsmVgoXDq2w",
                        title: "Manic Monday<br>The Bangles",
                        start: 18,
                        duration: 30
                    },
                    {
                        type: "audio",
                        youtube: "S2Cti12XBw4",
                        title: "Sunday Morning<br>Maroon 5",
                        start: 42,
                        duration: 30
                    },
                    {
                        type: "audio",
                        youtube: "GVCzdpagXOQ",
                        title: "Saturday<br>Rebecca Black",
                        start: 7,
                        duration: 30
                    },
                    "Last Friday Night<br>Katy Perry"
                ], answer: "Last Friday Night<br>Katy Perry", sequence: "Days Of The Week In Reverse", points: [5, 3, 2] }
            ],
            round3: [
                {
                    groups: [
                        { items: ["Times", "Courier", "Arial", "Instagram"], connection: "Fonts / Typefaces" },
                        { items: ["Twitter", "Spot", "Wrong", "Kisses"], connection: "Represented by <q>X</q>" },
                        { items: ["Pots", "Opts", "Post", "Tops"], connection: "STOP Anadrome" },
                        { items: ["Messenger", "Bearer", "Runner", "Page"], connection: "Synonyms for Postal/Mail Carriers" }
                    ]
                }
            ],
            round4: [
                {
                    category: "VIDEO GAME MASCOTS -AND- THEIR FRANCHISE",
                    clues: [
                        { withoutVowels: "PK CHN DP KMN", answer: "PIKACHU AND POKEMON" },
                        { withoutVowels: "MRN D SP RMR BRS", answer: "MARIO AND SUPER MARIO BROS" },
                        { withoutVowels: "SB LL ND NML CR SSN G", answer: "ISABELLE AND ANIMAL CROSSING" },
                        { withoutVowels: "PCM NN DPC MN", answer: "PAC-MAN AND PAC-MAN" }
                    ]
                },
                {
                    category: "ASTROLOGY SIGNS -AND- THE MONTH IN WHICH THEY START",
                    clues: [
                        { withoutVowels: "C N CRN DJ N", answer: "CANCER AND JUNE" },
                        { withoutVowels: "SG TTRS NDN VM BR", answer: "SAGITTARIUS AND NOVEMBER" },
                        { withoutVowels: "QRS ND JNR Y", answer: "AQUARIUS AND JANUARY" },
                        { withoutVowels: "LN D JLY", answer: "LEO AND JULY" }
                    ]
                },
                {
                    category: "OLYMPIC HOST CITIES AND COUNTRIES",
                    clues: [
                        { withoutVowels: "PR SFR N C", answer: "PARIS, FRANCE" },
                        { withoutVowels: "L ND NN GLN D", answer: "LONDON, ENGLAND" },
                        { withoutVowels: "NNSB R CKS TR", answer: "INNSBRUCK, AUSTRIA" },
                        { withoutVowels: "SL TL KCT YN TDS TTS", answer: "SALT LAKE CITY, UNITED STATES" }
                    ]
                },
                {
                    category: "BOOK TITLES WITH NUMBERS RAISED BY 1",
                    clues: [
                        { withoutVowels: "THR TN THN G HT", answer: "THIRTEENTH NIGHT" },
                        { withoutVowels: "TL FTH RCT S", answer: "(A) TALE OF THREE CITIES" },
                        { withoutVowels: "T WFS HT H RFS HR DFSH BL FSH", answer: "TWO FISH, THREE FISH, RED FISH, BLUE FISH" },
                        { withoutVowels: "THF RM SKTR S", answer: "THE FOUR MUSKETEERS" }
                    ]
                },
                {
                    category: "PROVERBIAL PHRASES",
                    clues: [
                        { withoutVowels: "NY FRN Y TT HFRT TH", answer: "AN EYE FOR AN EYE, A TOOTH FOR A TOOTH" },
                        { withoutVowels: "K NCK NWD", answer: "KNOCK ON WOOD" },
                        { withoutVowels: "NP NN GN", answer: "NO PAIN, NO GAIN" },
                        { withoutVowels: "P RCT CM KSP R FCT", answer: "PRACTICE MAKES PERFECT" }
                    ]
                }
            ]
        };

        // Game state
        let myRole = null; // 'host' or 'player1', 'player2', etc.
        let gameCode = null;
        let playerNames = '';
        let allPlayers = []; // Array of all player names
        let showSetupModal = true;
        let setupStep = 'initial'; // 'initial', 'createGame', 'joinGame', 'enterName'
        let score = 0;
        let view = 'rounds';
        let currentRound = null;
        let currentQuestion = null;
        let cluesRevealed = 0;
        let answerRevealed = false;
        let completedQuestions = [];
        let sequentialQuestionIndex = 0; // Track which question we're on in sequential play
        let timerStartTime = null;
        let timerInterval = null;
        let timerDuration = 60000;
        let timerElapsedWhenStopped = 0;
        let timerStopped = false;
        let timerStoppedOnClue = null;
        let timerRemainingWhenStopped = null;
        let showCluesTimeUpModal = false;

        // Round 3 (Connecting Wall) state
        let wallTiles = [];
        let selectedTiles = [];
        let solvedGroups = [];
        let wallLives = 3;
        let wallPhase = 'setup'; // 'setup', 'solving', 'guessing', 'complete'
        let connectionGuesses = {};
        let wallTimerStarted = false;
        let showWallTimeUpModal = false;
        let showWallFrozenModal = false;
        let wallAnimations = new Map(); // Track tile positions for animations

        // Round 4 (Missing Vowels) state
        let vowelsCurrentCategory = 0;
        let vowelsCurrentClue = 0;
        let vowelsCategoryRevealed = false;
        let vowelsCategoryAnimating = false;
        let vowelsClueRevealed = false;
        let vowelsAnswerRevealed = false;
        let vowelsShowTimeUpModal = false;
        
        // Buzzer state
        let buzzedInPlayer = null;

        // Category display
        let currentCategoryName = '';

        // Audio tester state
        let audioTesterPlaying = false;
        let audioTesterPaused = false;

        // Player statistics tracking
        let playerStats = {}; // { playerName: { total: 0, round1: 0, round2: 0, round4: 0, points5: 0, points3: 0, points2: 0, points1: 0 } }
        let showStatsView = false;

        // Firebase Realtime Database listeners
        let gameRef = null;
        let playersRef = null;
        let gameStateRef = null;
        
        // Helper to set up game references
        function setupGameReferences(code) {
            gameRef = database.ref(`games/${code}`);
            playersRef = gameRef.child('players');
            gameStateRef = gameRef.child('gameState');
        }
        
        // Create game
        function createGameInFirebase(code) {
            const newGameRef = database.ref(`games/${code}`);
            
            // Check if game already exists
            newGameRef.once('value').then((snapshot) => {
                if (snapshot.exists()) {
                    alert('Game code already exists. Please choose another.');
                } else {
                    // Create the game
                    newGameRef.set({
                        host: sessionId,
                        secondaryHost: null,
                        players: {},
                        gameState: {},
                        createdAt: firebase.database.ServerValue.TIMESTAMP
                    }).then(() => {
                        gameCode = code;
                        myRole = 'host';
                        showSetupModal = false;
                        setupGameReferences(code);
                        listenToPlayers();
                        listenToBuzzer();
                        listenToTileClicks();
                        render();
                    });
                }
            });
        }
        
        // Join game as player
        function joinGameInFirebase(code, name) {
            const checkGameRef = database.ref(`games/${code}`);
            
            checkGameRef.once('value').then((snapshot) => {
                if (!snapshot.exists()) {
                    alert('Game not found. Please check the code.');
                } else {
                    gameCode = code;
                    setupGameReferences(code);
                    
                    // Add player to the game
                    const playerRef = playersRef.push();
                    const playerRole = `player${Object.keys(snapshot.val().players || {}).length + 1}`;
                    
                    playerRef.set({
                        id: sessionId,
                        name: name,
                        role: playerRole,
                        joinedAt: firebase.database.ServerValue.TIMESTAMP
                    }).then(() => {
                        myRole = playerRole;
                        playerNames = name;
                        showSetupModal = false;
                        listenToPlayers();
                        listenToGameState();
                        render();
                    });
                }
            });
        }
        
        // Join as secondary host
        function joinAsSecondaryHostInFirebase(code) {
            const checkGameRef = database.ref(`games/${code}`);
            
            checkGameRef.once('value').then((snapshot) => {
                if (!snapshot.exists()) {
                    alert('Game not found. Please check the code.');
                } else {
                    gameCode = code;
                    myRole = 'secondaryHost';
                    setupGameReferences(code);
                    
                    // Set secondary host
                    gameRef.child('secondaryHost').set(sessionId).then(() => {
                        showSetupModal = false;
                        listenToPlayers();
                        listenToGameState();
                        render();
                    });
                }
            });
        }
        
        // Listen to players updates
        function listenToPlayers() {
            if (!playersRef) return;
            
            playersRef.on('value', (snapshot) => {
                const playersData = snapshot.val();
                if (playersData) {
                    allPlayers = Object.values(playersData);
                    
                    // Initialize stats for new players
                    if (isHost()) {
                        allPlayers.forEach(player => {
                            if (!playerStats[player.name]) {
                                playerStats[player.name] = {
                                    total: 0,
                                    round1: 0,
                                    round2: 0,
                                    round4: 0,
                                    points5: 0,
                                    points3: 0,
                                    points2: 0,
                                    points1: 0
                                };
                            }
                        });
                    }
                    
                    updatePlayerNamesDisplay();
                    render();
                }
            });
        }
        
        // Listen to game state updates (players and secondary host only)
        function listenToGameState() {
            if (!gameStateRef || isHost()) return;
            
            gameStateRef.on('value', (snapshot) => {
                const gameState = snapshot.val();
                if (!gameState) return;
                
                console.log('DEBUG Received game state update - view:', gameState.view);
                
                // Store the current timer state
                const wasTimerRunning = timerInterval !== null && !timerStopped;
                
                // Update all state from host
                score = gameState.score || 0;
                view = gameState.view || 'rounds';
                currentRound = gameState.currentRound;
                currentQuestion = gameState.currentQuestion;
                cluesRevealed = gameState.cluesRevealed || 0;
                answerRevealed = gameState.answerRevealed || false;
                completedQuestions = gameState.completedQuestions || [];
                timerStopped = gameState.timerStopped || false;
                timerElapsedWhenStopped = gameState.timerElapsedWhenStopped || 0;
                timerStartTime = gameState.timerStartTime;
                timerDuration = gameState.timerDuration || 60000;
                timerStoppedOnClue = gameState.timerStoppedOnClue;
                timerRemainingWhenStopped = gameState.timerRemainingWhenStopped;
                buzzedInPlayer = gameState.buzzedInPlayer;
                showCluesTimeUpModal = gameState.showCluesTimeUpModal || false;
                
                // Wall state
                const previousWallTiles = wallTiles.map(t => ({...t}));
                const previousSolvedGroups = solvedGroups.length;
                const wasInWallView = (view === 'wall');
                const wasTimerStarted = wallTimerStarted;
                
                wallTiles = gameState.wallTiles || [];
                selectedTiles = gameState.selectedTiles || [];
                solvedGroups = gameState.solvedGroups || [];
                wallLives = gameState.wallLives || 3;
                wallPhase = gameState.wallPhase || 'setup';
                connectionGuesses = gameState.connectionGuesses || {};
                wallTimerStarted = gameState.wallTimerStarted || false;
                showTimeUpModal = gameState.showTimeUpModal || false;
                showWallFrozenModal = gameState.showWallFrozenModal || false;
                
                // For players/secondary hosts: detect if tiles need to be animated
                if (!isHost() && wasInWallView && view === 'wall' && previousWallTiles.length > 0 
                    && wasTimerStarted && wallTimerStarted) {
                    
                    const positionsChanged = wallTiles.some((tile) => {
                        const prevTile = previousWallTiles.find(t => t.id === tile.id);
                        return prevTile && prevTile.position !== tile.position;
                    });
                    
                    if (positionsChanged || solvedGroups.length > previousSolvedGroups) {
                        window._needsWallPositionUpdate = true;
                        window._previousWallTiles = previousWallTiles;
                    } else {
                        window._needsWallPositionUpdate = false;
                    }
                } else {
                    window._needsWallPositionUpdate = false;
                }
                
                // Vowels state
                vowelsCurrentCategory = gameState.vowelsCurrentCategory || 0;
                vowelsCurrentClue = gameState.vowelsCurrentClue || 0;
                vowelsCategoryRevealed = gameState.vowelsCategoryRevealed || false;
                vowelsCategoryAnimating = gameState.vowelsCategoryAnimating || false;
                vowelsClueRevealed = gameState.vowelsClueRevealed || false;
                vowelsAnswerRevealed = gameState.vowelsAnswerRevealed || false;
                vowelsShowTimeUpModal = gameState.vowelsShowTimeUpModal || false;
                currentCategoryName = gameState.currentCategoryName || '';

                // Audio titles revealed state
                window._audioTitlesRevealed = gameState.audioTitlesRevealed || {};

                // Player statistics
                playerStats = gameState.playerStats || {};

                // Audio tester state
                audioTesterPlaying = gameState.audioTesterPlaying || false;
                audioTesterPaused = gameState.audioTesterPaused || false;
                
                // Handle timer state
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
        
                if (timerStopped && timerRemainingWhenStopped !== null) {
                    updateTimerDisplay(timerRemainingWhenStopped);
                } else if (!timerStopped && timerStartTime) {
                    const now = Date.now();
                    const elapsed = timerElapsedWhenStopped + (now - timerStartTime);
                    const remaining = Math.max(0, timerDuration - elapsed);
                    
                    updateTimerDisplay(remaining);
                    
                    if (remaining > 0) {
                        timerInterval = setInterval(updateTimer, 100);
                    }
                }
                
                // Special handling for wall tile animations on non-host clients
                if (window._needsWallPositionUpdate) {
                    window._needsWallPositionUpdate = false;
                    updateWallStateWithoutRender();
                    setTimeout(() => {
                        updateTilePositionsInDOM();
                    }, 50);
                } else {
                    render();
                }
            });
        }
        
        // Player buzzes in
        function buzzIn() {
            if (!isPlayer() || !gameCode) return;
            
            database.ref(`games/${gameCode}/buzzer`).set({
                playerName: playerNames,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
        }
        
        // Listen for buzzer (host only)
        function listenToBuzzer() {
            if (!isHost() || !gameCode) return;
            
            database.ref(`games/${gameCode}/buzzer`).on('value', (snapshot) => {
                const buzzerData = snapshot.val();
                if (buzzerData && buzzerData.playerName) {
                    buzzedInPlayer = buzzerData.playerName;
                    stopTimer();
                    
                    // Clear the buzzer after handling
                    database.ref(`games/${gameCode}/buzzer`).remove();
                    
                    // Update game state
                    syncGameState();
                    render();
                }
            });
        }
        
        // Player clicks tile (wall)
        function playerClicksTile(tileId) {
            if (!isPlayer() || !gameCode) return;
            
            database.ref(`games/${gameCode}/tileClick`).set({
                tileId: tileId,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
        }
        
        // Listen for tile clicks (host only)
        function listenToTileClicks() {
            if (!isHost() || !gameCode) return;
            
            database.ref(`games/${gameCode}/tileClick`).on('value', (snapshot) => {
                const tileClickData = snapshot.val();
                if (tileClickData && tileClickData.tileId !== undefined) {
                    console.log('DEBUG Host received tile click:', tileClickData.tileId);
                    toggleTile(tileClickData.tileId);
                    
                    // Clear the tile click after handling
                    database.ref(`games/${gameCode}/tileClick`).remove();
                }
            });
        }

        // Initialize host listeners when game is created
        function initializeHostListeners() {
            if (isHost() && gameCode) {
                listenToBuzzer();
                listenToTileClicks();
            }
        }
        
        // Helper functions
        function isHost() {
            return myRole === 'host';
        }

        function isPlayer() {
            return myRole && myRole.startsWith('player');
        }

        function isSecondaryHost() {
            return myRole === 'secondaryHost';
        }

        function syncGameState() {
            if (!isHost()) return;
            
            const state = {
                // Basic game state
                score,
                view,
                currentRound,
                currentQuestion,
                currentCategoryName: currentCategoryName || '',
                
                // Clues state
                cluesRevealed,
                answerRevealed,
                completedQuestions,
                buzzedInPlayer,
                
                // Timer state
                timerStopped,
                timerElapsedWhenStopped,
                timerRemainingWhenStopped,
                timerStartTime,
                timerDuration,
                timerStoppedOnClue,
                
                // Modal states
                showCluesTimeUpModal,
                showTimeUpModal,
                showWallFrozenModal,
                vowelsShowTimeUpModal,
                
                // Wall state
                wallTiles,
                selectedTiles,
                solvedGroups,
                wallLives,
                wallPhase,
                connectionGuesses,
                wallTimerStarted,
                
                // Vowels state
                vowelsCurrentCategory,
                vowelsCurrentClue,
                vowelsCategoryRevealed,
                vowelsCategoryAnimating,
                vowelsClueRevealed,
                vowelsAnswerRevealed,
                
                // Audio titles revealed state
                audioTitlesRevealed: window._audioTitlesRevealed || {},

                // Player statistics
                playerStats: playerStats

                state.audioTesterPlaying = audioTesterPlaying;
                state.audioTesterPaused = audioTesterPaused;
            };
            
            if (gameStateRef) {
                gameStateRef.set(state);
            }
        }
        
        function broadcastAction(type, params = []) {
            // Firebase handles state sync automatically, no need for separate actions
            if (!isHost()) return;
            // Actions are handled through gameState sync
        }
        
        function updatePlayerNamesDisplay() {
            if (isHost() || isSecondaryHost()) {
                if (allPlayers.length === 0) {
                    playerNames = "Waiting for players...";
                } else if (allPlayers.length === 1) {
                    playerNames = allPlayers[0].name;
                } else if (allPlayers.length === 2) {
                    playerNames = allPlayers[0].name + " & " + allPlayers[1].name;
                } else {
                    const lastPlayer = allPlayers[allPlayers.length - 1].name;
                    const otherPlayers = allPlayers.slice(0, -1).map(p => p.name).join(", ");
                    playerNames = otherPlayers + ", & " + lastPlayer;
                }
            }
        }

        // Timer functions
        function startTimer() {
            if (timerStartTime === null) {
                // Reset all modal states when starting a new timer
                resetAllModals();
                
                // Reset timer state
                timerStartTime = Date.now();
                timerStopped = false;
                timerElapsedWhenStopped = 0;
                timerRemainingWhenStopped = null;  // Clear any frozen time
                
                // Start the timer
                timerInterval = setInterval(updateTimer, 100);
                
                // Sync the state if host
                if (isHost()) {
                    syncGameState();
                }
            }
        }
        
        function resetAllModals() {
            showTimeUpModal = false;
            showCluesTimeUpModal = false;
            vowelsShowTimeUpModal = false;
        }

        function updateTimer() {
            // Don't update if timer is stopped
            if (timerStopped) return;
            
            if (!timerStartTime) return;

            const now = Date.now();
            const elapsed = timerElapsedWhenStopped + (now - timerStartTime);
            const remaining = Math.max(0, timerDuration - elapsed);

            updateTimerDisplay(remaining);

            if (remaining <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;

                if (isHost()) {
                    handleTimerExpiration();
                }
            }
        }
        
        function updateTimerDisplay(remaining) {
            const percentage = (remaining / timerDuration) * 100;
            const seconds = Math.ceil(remaining / 1000);
            
            // Update all timer bars and texts (there might be multiple)
            for (let i = 0; i < 4; i++) {
                const timerBar = document.getElementById(`timerBar-${i}`);
                const timerText = document.getElementById(`timerText-${i}`);
                if (timerBar) timerBar.style.width = percentage + '%';
                if (timerText) timerText.textContent = seconds + 's';
            }
            
            // Also update the non-indexed ones for other rounds
            const mainTimerBar = document.getElementById('timerBar');
            const mainTimerText = document.getElementById('timerText');
            if (mainTimerBar) mainTimerBar.style.width = percentage + '%';
            if (mainTimerText) mainTimerText.textContent = seconds + 's';
        }

        function handleTimerExpiration() {
            if (!isHost()) return;
            
            // Set the appropriate modal flag based on current view
            if (view === 'clues') {
                // Stop any playing audio when time expires
                stopAllAudioClues();
                
                showCluesTimeUpModal = true;
                timerStopped = true;
                timerRemainingWhenStopped = 0;  // Freeze at 0 when time expires
                
                // Lock the timer position when time expires
                if (timerStoppedOnClue === null) {
                    timerStoppedOnClue = Math.max(0, cluesRevealed - 1);
                }
            } else if (view === 'wall') {
                showWallFrozenModal = true;
                timerStopped = true;
            } else if (view === 'vowels') {
                vowelsShowTimeUpModal = true;
                timerStopped = true;
            }
            
            syncGameState();
            render();
        }

        function dismissTimeUpModal() {
            if (!isHost()) return;
            
            // Clear the modal flag
            showCluesTimeUpModal = false;
            
            // Make sure timer is fully stopped
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerStopped = true;
            
            // Sync state to all clients FIRST
            syncGameState();
            
            // Then broadcast the specific action
            broadcastAction('dismissTimeUpModal');
            
            // Finally render for host
            render();
        }

        function stopAllAudioClues() {
            // Find all audio iframes and remove them from DOM to stop playback
            const audioIframes = document.querySelectorAll('[id^="audio-clue-"]');
            audioIframes.forEach(iframe => {
                iframe.remove();
            });
        }
        
        function resetTimer() {
            // Clear any running timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Reset timer state
            timerStartTime = null;
            timerStopped = false;
            timerElapsedWhenStopped = 0;
            timerStoppedOnClue = null;
            timerRemainingWhenStopped = null;
            
            // Reset modal states
            showTimeUpModal = false;
            showCluesTimeUpModal = false;
            vowelsShowTimeUpModal = false;
            
            // If host, sync the state
            if (isHost()) {
                syncGameState();
            }
        }
        
        function stopTimer() {
            // First, capture the remaining time BEFORE clearing anything
            if (timerStartTime && !timerStopped) {
                const elapsed = timerElapsedWhenStopped + (Date.now() - timerStartTime);
                timerRemainingWhenStopped = Math.max(0, timerDuration - elapsed);
            }
            
            // Clear the interval
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Update elapsed time
            if (timerStartTime) {
                timerElapsedWhenStopped += Date.now() - timerStartTime;
                timerStartTime = null;
            }
            
            timerStopped = true;

            // Stop any playing audio when timer stops
            stopAllAudioClues();
            
            // Record which clue the timer stopped on (for clues view)
            if (view === 'clues' && timerStoppedOnClue === null) {
                timerStoppedOnClue = Math.max(0, cluesRevealed - 1);
            }
            
            // Update the display with the frozen time
            if (timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            }
            
            // Sync the state if host
            if (isHost()) {
                syncGameState();
            }
        }

        // Keyboard event listener for spacebar (players only)
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && isPlayer()) {
                if ((view === 'clues' && cluesRevealed > 0 && !timerStopped) ||
                    (view === 'vowels' && vowelsCategoryRevealed && vowelsClueRevealed && !timerStopped)) {
                    event.preventDefault();
                    buzzIn();
                }
            }
        });

        // Game functions with role restrictions
        function selectRound(roundIndex) {
            console.log('DEBUG selectRound called - isHost:', isHost(), 'roundIndex:', roundIndex);
            
            if (!isHost()) {
                console.log('DEBUG Non-host received selectRound - ignoring direct call, will receive via sync');
                return;
            }

            // Stop audio tester when leaving round selector
            stopAudioTester();
            
            console.log('DEBUG Host selectRound - processing roundIndex:', roundIndex);
            
            currentRound = roundIndex;
            
            // Reset all modals when switching rounds
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            
            // Clear question state when changing rounds
            currentQuestion = null;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerStoppedOnClue = null;
            timerRemainingWhenStopped = null;
            buzzedInPlayer = null;
            resetTimer();
            
            if (roundIndex === 2) {
                console.log('DEBUG Host initializing Round 3: Wall');
                view = 'wall';
                currentCategoryName = "Connecting Wall";
                initializeWall();
            } else if (roundIndex === 3) {
                console.log('DEBUG Host initializing Round 4: Vowels');
                view = 'vowels';
                currentCategoryName = "Missing Vowels";
                initializeVowels();
            } else {
                // For rounds 0 (Connections) and 1 (Sequences)
                console.log('DEBUG Host initializing Round', roundIndex, '(Questions)');
                view = 'questions';
                currentCategoryName = '';
                
                // Set sequential index based on completed questions
                const questionsInRound = roundIndex === 0 ? gameData.round1.length : gameData.round2.length;
                sequentialQuestionIndex = 0;
                for (let i = 0; i < questionsInRound; i++) {
                    const questionKey = `r${roundIndex}q${i}`;
                    if (completedQuestions.includes(questionKey)) {
                        sequentialQuestionIndex = i + 1;
                    } else {
                        break;
                    }
                }
            }
            
            console.log('DEBUG After selectRound - view:', view, 'currentRound:', currentRound, 'wallTiles.length:', wallTiles.length);
            
            // Don't broadcast selectRound - just sync the full state
            syncGameState();
            render();
        }

        function selectQuestion(questionIndex) {
            if (!isHost()) return;
            
            const isExample = questionIndex === 'example';
            const questionKey = isExample ? `r${currentRound}qExample` : `r${currentRound}q${questionIndex}`;
            if (completedQuestions.includes(questionKey)) return;
            
            // Reset all relevant states
            currentQuestion = isExample ? 'example' : questionIndex;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerElapsedWhenStopped = 0;
            timerStartTime = null;
            timerStoppedOnClue = null;
            timerElapsedWhenStopped = null;
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            buzzedInPlayer = null;
            window._audioTitlesRevealed = {}; // Reset audio title reveals for new question
            
            // Reset the timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Set category name and timer duration
            switch (currentRound) {
                case 0:
                    currentCategoryName = "Connections";
                    break;
                case 1:
                    currentCategoryName = "Sequences";
                    break;
            }
            
            // Set the view to 'clues' and timer duration
            view = 'clues';
            timerDuration = 60000; // 1 minute for each question
            
            // Sync the state with players
            syncGameState();
            render();
        }

        function revealClue(index) {
            if (!isHost()) return;
            
            const isSequence = currentRound === 1;
            
            // For sequences, allow revealing clue 4 directly if timer is stopped (someone buzzed)
            if (isSequence && index === 3 && timerStopped && cluesRevealed < 4) {
                cluesRevealed = 4; // Jump to revealing clue 4
                broadcastAction('revealClue', [index]);
                syncGameState();
                render();
                return;
            }
            
            if (index === cluesRevealed) {
                if (isSequence && index === 3 && !timerStopped) {
                    return;
                }
                
                cluesRevealed++;
                
                // Only start timer if not already stopped (by buzzer or timeout)
                if (!timerStopped && cluesRevealed < 4) {
                    startTimer();
                }
                
                broadcastAction('revealClue', [index]);
                syncGameState();
                render();
            }
        }

        function showAudioTitle(index) {
            if (!isHost()) return;
            
            // Mark this specific audio clue as having its title revealed
            if (!window._audioTitlesRevealed) {
                window._audioTitlesRevealed = {};
            }
            const titleKey = `${currentRound}-${currentQuestion}-${index}`;
            window._audioTitlesRevealed[titleKey] = true;
            
            // Immediately render to show the title
            render();
            
            // Then sync to other players
            syncGameState();
        }

        function markCorrect() {
            if (!isHost()) return;
            
            const isExample = currentQuestion === 'example';
            const isSequence = currentRound === 1;
            let question;
            if (isExample) {
                question = isSequence ? gameData.exampleRound2 : gameData.exampleRound1;
            } else {
                question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            }
            const pointsValues = question.points;
            const pointsEarned = pointsValues[timerStoppedOnClue];
            
            // Only add points if not an example question
            if (!isExample) {
                score += pointsEarned;
                
                // Track player stats if someone buzzed in
                if (buzzedInPlayer && playerStats[buzzedInPlayer]) {
                    playerStats[buzzedInPlayer].total += pointsEarned;
                    
                    // Track by round
                    if (currentRound === 0) {
                        playerStats[buzzedInPlayer].round1 += pointsEarned;
                    } else if (currentRound === 1) {
                        playerStats[buzzedInPlayer].round2 += pointsEarned;
                    }
                    
                    // Track by point value
                    if (pointsEarned === 5) {
                        playerStats[buzzedInPlayer].points5++;
                    } else if (pointsEarned === 3) {
                        playerStats[buzzedInPlayer].points3++;
                    } else if (pointsEarned === 2) {
                        playerStats[buzzedInPlayer].points2++;
                    } else if (pointsEarned === 1) {
                        playerStats[buzzedInPlayer].points1++;
                    }
                }
            }
        
            // Stop any playing audio
            stopAllAudioClues();
            
            answerRevealed = true;
            buzzedInPlayer = null;
            
            broadcastAction('markCorrect');
            syncGameState();
            render();
        }

        function markIncorrect() {
            if (!isHost()) return;

            // Stop any playing audio
            stopAllAudioClues();
            
            answerRevealed = true;
            buzzedInPlayer = null;
            
            broadcastAction('markIncorrect');
            syncGameState();
            render();
        }

        // Player-side function to handle the broadcast
        function revealRemainingCluesFromPlayerSide() {
            // This will be called via gameAction broadcast
            // The state sync from host will handle everything
            render();
        }

        function completeQuestion() {
            if (!isHost()) return;
            
            console.log('DEBUG completeQuestion - currentRound:', currentRound, 'currentQuestion:', currentQuestion);
            
            const isExample = currentQuestion === 'example';
            const questionKey = isExample ? `r${currentRound}qExample` : `r${currentRound}q${currentQuestion}`;
            if (!completedQuestions.includes(questionKey)) {
                completedQuestions.push(questionKey);
            }
            
            // Reset all modals when completing a question
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            
            // Broadcast the completion
            broadcastAction('completeQuestion');
            
            // Auto-advance logic
            const questionsInCurrentRound = currentRound === 0 ? gameData.round1.length : gameData.round2.length;
            
            console.log('DEBUG questionsInCurrentRound:', questionsInCurrentRound);
            console.log('DEBUG isExample:', isExample);
            
            if (isExample) {
                // After example, move to first real question
                console.log('DEBUG Moving from example to first question');
                selectQuestion(0);
            } else if (currentQuestion < questionsInCurrentRound - 1) {
                // Move to next question in same round
                console.log('DEBUG Moving to next question:', currentQuestion + 1);
                selectQuestion(currentQuestion + 1);
            } else {
                // Finished round
                console.log('DEBUG Finished round', currentRound, '- moving to next round');
                
                if (currentRound === 0) {
                    // Move from Round 1 to Round 2
                    console.log('DEBUG Moving from Round 1 to Round 2');
                    sequentialQuestionIndex = 0;
                    selectRound(1);
                } else if (currentRound === 1) {
                    // Move from Round 2 to Round 3 (Wall)
                    console.log('DEBUG Moving from Round 2 to Round 3 (Wall)');
                    selectRound(2);
                } else {
                    // Shouldn't happen with current flow, but fallback
                    console.log('DEBUG Unexpected round completion - going back to rounds');
                    backToRounds();
                }
            }
        }

        function backToRounds() {
            if (!isHost()) return;
            
            view = 'rounds';
            currentRound = null;
            currentQuestion = null;
            resetTimer();
            
            broadcastAction('backToRounds');
            syncGameState();
            render();
        }

        function playAudioTester() {
            if (!isHost()) return;
            
            audioTesterPlaying = true;
            audioTesterPaused = false;
            
            syncGameState();
            render();
        }
        
        function pauseAudioTester() {
            if (!isHost()) return;
            
            audioTesterPaused = true;
            
            syncGameState();
            render();
        }
        
        function stopAudioTester() {
            if (!isHost()) return;
            
            audioTesterPlaying = false;
            audioTesterPaused = false;
            
            // Remove the iframe to stop audio
            const iframe = document.getElementById('audio-tester-iframe');
            if (iframe) {
                iframe.remove();
            }
            
            syncGameState();
            render();
        }

        function backToQuestions() {
            if (!isHost()) return;
            
            view = 'questions';
            currentQuestion = null;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerStoppedOnClue = null;
            showCluesTimeUpModal = false;
            buzzedInPlayer = null;
            resetTimer();
            
            broadcastAction('backToQuestions');
            syncGameState();
            render();
        }

        function endGame() {
            if (!isHost()) return;
            
            view = 'finalScore';
            
            broadcastAction('endGame');
            syncGameState();
            render();
        }

        function viewStats() {
            if (!isHost()) return;
            
            showStatsView = true;
            render();
        }
        
        function closeStats() {
            if (!isHost()) return;
            
            showStatsView = false;
            render();
        }

        function endSession() {
            if (!isHost()) return;
            
            // Clean up the game from Firebase before reloading
            if (gameCode && gameRef) {
                gameRef.remove().then(() => {
                    location.reload();
                }).catch(() => {
                    location.reload();
                });
            } else {
                location.reload();
            }
        }

        // Round 4 (Missing Vowels) functions
        function initializeVowels() {
            vowelsCurrentCategory = 0;
            vowelsCurrentClue = 0;
            vowelsCategoryRevealed = false;
            vowelsCategoryAnimating = false;
            vowelsClueRevealed = false;
            vowelsAnswerRevealed = false;
            vowelsShowTimeUpModal = false;
            resetTimer();
            timerDuration = 150000;
        }

        function revealCategoryAndStartTimer() {
            if (!isHost()) return;
            
            if (!vowelsCategoryRevealed) {
                vowelsCategoryRevealed = true;
                vowelsCategoryAnimating = true;
                
                // Don't change currentCategoryName - keep it as "Missing Vowels"
                
                syncGameState();
                render();
                
                setTimeout(() => {
                    vowelsCategoryAnimating = false;
                    vowelsClueRevealed = true;
                    // Only start timer if it hasn't been started yet
                    if (timerStartTime === null) {
                        startTimer();
                    }
                    
                    broadcastAction('revealCategoryAndStartTimer');
                    syncGameState();
                    render();
                }, 3000);
            }
        }

        function markVowelsCorrect() {
            if (!isHost()) return;
            
            console.log('DEBUG markVowelsCorrect called');
            console.log('Timer stopped:', timerStopped);
            console.log('Buzzer cleared');
            
            score += 1;
            
            // Track player stats for Missing Vowels (1 point each)
            if (buzzedInPlayer && playerStats[buzzedInPlayer]) {
                playerStats[buzzedInPlayer].total += 1;
                playerStats[buzzedInPlayer].round4 += 1;
                playerStats[buzzedInPlayer].points1++;
            }
            
            vowelsAnswerRevealed = true;
            buzzedInPlayer = null;
            
            setTimeout(() => {
                const clueElement = document.querySelector('.vowels-clue-text');
                if (clueElement) {
                    const letters = clueElement.querySelectorAll('.vowels-letter');
                    letters.forEach(letter => {
                        if (letter.classList.contains('vowel')) {
                            letter.classList.add('revealed');
                        }
                    });
                }
            }, 50);
            
            broadcastAction('markVowelsCorrect');
            syncGameState();
            render();
        }

        function markVowelsIncorrect() {
            if (!isHost()) return;
            
            vowelsAnswerRevealed = true;
            buzzedInPlayer = null;  // Clear the buzzer
            
            // DON'T restart timer here - it will restart when next clue is revealed
            
            setTimeout(() => {
                const clueElement = document.querySelector('.vowels-clue-text');
                if (clueElement) {
                    const letters = clueElement.querySelectorAll('.vowels-letter');
                    letters.forEach(letter => {
                        if (letter.classList.contains('vowel')) {
                            letter.classList.add('revealed');
                        }
                    });
                }
            }, 50);
            
            broadcastAction('markVowelsIncorrect');
            syncGameState();
            render();
        }

        function nextVowelsClue() {
            if (!isHost()) return;
            
            console.log('DEBUG nextVowelsClue called');
            console.log('Current category:', vowelsCurrentCategory);
            console.log('Current clue:', vowelsCurrentClue);
            console.log('Timer stopped:', timerStopped);
            console.log('Timer elapsed when stopped:', timerElapsedWhenStopped);
            console.log('Timer remaining when stopped:', timerRemainingWhenStopped);
            
            const category = gameData.round4[vowelsCurrentCategory];
            // ... rest of function
            
            if (vowelsCurrentClue < category.clues.length - 1) {
                vowelsCurrentClue++;
                vowelsClueRevealed = true;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;  // Clear buzzer for next clue
                
                // Restart the timer from where it was stopped
                if (timerStopped) {
                    timerStopped = false;
                    timerStartTime = Date.now();
                    timerRemainingWhenStopped = null;  // Clear the frozen time
                    // timerElapsedWhenStopped keeps its value to continue from where we left off
                    if (!timerInterval) {
                        timerInterval = setInterval(updateTimer, 100);
                    }
                }
                
                broadcastAction('nextVowelsClue');
                syncGameState();
                render();
            } else {
                // End of category - stop timer and show category complete state
                stopTimer();
                vowelsClueRevealed = false;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;
                
                syncGameState();
                render();
            }
        }

        function nextVowelsCategory() {
            if (!isHost()) return;
            
            const category = gameData.round4[vowelsCurrentCategory];
            
            // Only advance if we've completed all clues in current category
            if (vowelsCurrentClue !== category.clues.length - 1 || !vowelsAnswerRevealed) {
                return;
            }
            
            if (vowelsCurrentCategory < gameData.round4.length - 1) {
                vowelsCurrentCategory++;
                vowelsCurrentClue = 0;
                vowelsCategoryRevealed = true;
                vowelsCategoryAnimating = true;
                vowelsClueRevealed = false;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;
                
                syncGameState();
                render();
                
                setTimeout(() => {
                    vowelsCategoryAnimating = false;
                    vowelsClueRevealed = true;
                    
                    // Restart timer from where it left off
                    if (timerStopped) {
                        timerStopped = false;
                        timerStartTime = Date.now();
                        timerRemainingWhenStopped = null;
                        // timerElapsedWhenStopped keeps its value
                        if (!timerInterval) {
                            timerInterval = setInterval(updateTimer, 100);
                        }
                    }
                    
                    broadcastAction('nextVowelsCategory');
                    syncGameState();
                    render();
                }, 3000);
            }
        }

        function revealVowelsAnswerFromModal() {
            if (!isHost()) return;
            
            vowelsShowTimeUpModal = false;
            
            // When time runs out, immediately move to end game state
            // Don't play through remaining clues
            vowelsClueRevealed = false;
            vowelsAnswerRevealed = true;
            stopTimer();
            
            broadcastAction('revealVowelsAnswerFromModal');
            syncGameState();
            render();
        }

        function isVowel(char) {
            return 'AEIOU'.includes(char.toUpperCase());
        }

        function createAnimatedClueText(withoutVowels, fullAnswer, revealed) {
            if (revealed) {
                // When revealed, just show the plain answer without any special formatting
                return `<div class="vowels-clue-text" style="letter-spacing: normal; gap: 0;">${fullAnswer}</div>`;
            }
            
            // When not revealed, show with vowels hidden
            const answerChars = fullAnswer.split('');
            
            let html = '<div class="vowels-clue-text">';
            
            for (let i = 0; i < answerChars.length; i++) {
                const char = answerChars[i];
                
                if (char === ' ') {
                    html += '<span class="vowels-letter" style="width: 1em;"> </span>';
                } else if (isVowel(char)) {
                    const vowelClass = 'vowels-letter vowel';
                    html += `<span class="${vowelClass}">${char}</span>`;
                } else {
                    html += `<span class="vowels-letter">${char}</span>`;
                }
            }
            
            html += '</div>';
            return html;
        }

        // Round 3 (Connecting Wall) functions
        function initializeWall() {
            // ONLY the host should shuffle tiles - players will receive the shuffled array via sync
            if (!isHost()) {
                console.log('DEBUG initializeWall called on non-host - skipping shuffle, will receive via sync');
                // Don't shuffle or create tiles - just initialize other state
                selectedTiles = [];
                solvedGroups = [];
                wallLives = 3;
                wallPhase = 'setup';
                connectionGuesses = {};
                wallTimerStarted = false;
                showWallTimeUpModal = false;
                showWallFrozenModal = false;
                resetTimer();
                timerDuration = 180000;
                return; // Exit early for non-hosts
            }
            
            const wallData = gameData.round3[0];
            
            console.log('DEBUG HOST initializeWall called');
            
            // Create tiles with unique IDs
            let allTiles = [];
            let tileId = 0;
            
            wallData.groups.forEach((group, groupIndex) => {
                group.items.forEach(item => {
                    allTiles.push({ 
                        id: tileId,
                        text: item, 
                        groupIndex: groupIndex,
                        solved: false,
                        position: tileId
                    });
                    tileId++;
                });
            });
            
            // Shuffle the tiles (HOST ONLY)
            wallTiles = shuffleArray(allTiles);
            
            // Re-assign positions after shuffle (0-15)
            wallTiles.forEach((tile, index) => {
                tile.position = index;
            });
            
            console.log('DEBUG HOST Wall initialized with', wallTiles.length, 'tiles');
            console.log('DEBUG HOST First 3 tiles:', wallTiles.slice(0, 3).map(t => t.text));
            
            selectedTiles = [];
            solvedGroups = [];
            wallLives = 3;
            wallPhase = 'setup';
            connectionGuesses = {};
            wallTimerStarted = false;
            showWallTimeUpModal = false;
            showWallFrozenModal = false;
            
            // Reset timer but don't start it
            resetTimer();
            timerDuration = 180000; // 3 minutes
        }

        function startWallTimer() {
            if (!isHost() || wallTimerStarted) return;
            
            wallTimerStarted = true;
            wallPhase = 'solving';
            startTimer();
            
            broadcastAction('startWallTimer');
            syncGameState();
            render();
        }

        function handleWallTimerExpired() {
            if (!isHost()) return;
            
            showWallTimeUpModal = true;
            timerStopped = true;
            
            syncGameState();
            render();
        }

        function toggleTile(tileId) {
            if (!wallTimerStarted) return;
            if (wallPhase !== 'solving') return;
            if (timerStopped) return;
            
            const tile = wallTiles.find(t => t.id === tileId);
            if (!tile || tile.solved) return;
            
            const selectedIndex = selectedTiles.indexOf(tileId);
            const element = document.querySelector(`[data-tile-id="${tileId}"]`);
            
            if (selectedIndex > -1) {
                // Deselect
                selectedTiles.splice(selectedIndex, 1);
                if (element) element.classList.remove('selected');
            } else {
                if (selectedTiles.length < 4) {
                    // Select
                    selectedTiles.push(tileId);
                    if (element) element.classList.add('selected');
                    
                    // Auto-submit when 4 tiles are selected
                    if (selectedTiles.length === 4) {
                        setTimeout(() => {
                            checkGroup();
                        }, 300);
                    }
                }
            }
            
            // Sync state but DON'T render
            if (isHost()) {
                syncGameState();
            }
        }

        function checkGroup() {
            if (selectedTiles.length !== 4) return;
            
            const selectedGroupIndices = selectedTiles.map(tileId => {
                const tile = wallTiles.find(t => t.id === tileId);
                return tile ? tile.groupIndex : -1;
            });
            const firstGroup = selectedGroupIndices[0];
            const allSame = selectedGroupIndices.every(g => g === firstGroup);
            
            if (allSame) {
                // Correct group!
                const wallData = gameData.round3[0];
                const groupItems = selectedTiles.map(tileId => {
                    const tile = wallTiles.find(t => t.id === tileId);
                    return tile ? tile.text : '';
                }).sort();
                
                // Mark tiles as solved
                selectedTiles.forEach(tileId => {
                    const tile = wallTiles.find(t => t.id === tileId);
                    if (tile) {
                        tile.solved = true;
                        tile.solvedGroupIndex = solvedGroups.length;
                    }
                });
                
                solvedGroups.push({
                    items: groupItems,
                    connection: wallData.groups[firstGroup].connection,
                    groupIndex: firstGroup,
                    solvedGroupIndex: solvedGroups.length
                });
                
                selectedTiles = [];
                score += 1;
                
                // RECALCULATE tile positions before animating
                recalculateWallPositions();
                
                // Update positions WITHOUT calling render() - let CSS animate!
                updateTilePositionsInDOM();
                
                // If 3 groups found, auto-solve the 4th after animation
                if (solvedGroups.length === 3) {
                    setTimeout(() => {
                        autoSolveLastGroup();
                        // Move to guessing phase after final animation
                        setTimeout(() => {
                            wallPhase = 'guessing';
                            stopTimer();
                            if (isHost()) {
                                syncGameState();
                            }
                            render(); // Now we can render for guessing phase
                        }, 1000);
                    }, 800);
                } else {
                    // Sync state but DON'T render
                    if (isHost()) {
                        syncGameState();
                    }
                }
            } else {
                // Incorrect guess
                const remainingGroups = 4 - solvedGroups.length;
                
                // Deselect tiles visually without re-rendering
                selectedTiles.forEach(tileId => {
                    const element = document.querySelector(`[data-tile-id="${tileId}"]`);
                    if (element) {
                        element.classList.remove('selected');
                    }
                });
                selectedTiles = [];
                
                if (remainingGroups === 2) {
                    wallLives--;
                    
                    // Update lives display manually
                    const livesDisplay = document.querySelector('.lives-display');
                    if (livesDisplay) {
                        livesDisplay.innerHTML = `Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}`;
                    }
                    
                    if (wallLives === 0) {
                        stopTimer();
                        showWallFrozenModal = true;
                        
                        // Add modal to DOM manually
                        const gameContainer = document.querySelector('.game-container');
                        if (gameContainer) {
                            const modalHtml = `
                                <div class="wall-frozen-modal">
                                    <div class="wall-frozen-content">
                                        <div class="wall-frozen-title">The Wall has Frozen!</div>
                                        ${isHost() ? '<button class="btn btn-primary" onclick="resolveWallFrozen()">Resolve Wall</button>' : ''}
                                    </div>
                                </div>
                            `;
                            gameContainer.insertAdjacentHTML('beforeend', modalHtml);
                        }
                    }
                }
                
                if (isHost()) {
                    syncGameState();
                }
            }
        }

        function handleCorrectGroup() {
            const groupIndex = wallTiles.find(t => t.id === selectedTiles[0]).groupIndex;
            const wallData = gameData.round3[0];
            
            // Sort selected tiles alphabetically before marking as solved
            const sortedSelectedTiles = selectedTiles.slice().sort((aId, bId) => {
                const tileA = wallTiles.find(t => t.id === aId);
                const tileB = wallTiles.find(t => t.id === bId);
                return tileA.text.localeCompare(tileB.text);
            });
            
            // Mark tiles as solved
            sortedSelectedTiles.forEach(tileId => {
                const tile = wallTiles.find(t => t.id === tileId);
                tile.solved = true;
                tile.solvedGroupIndex = solvedGroups.length;
            });
            
            // Add to solved groups with sorted tiles
            solvedGroups.push({
                tiles: sortedSelectedTiles,
                groupIndex: groupIndex,
                connection: wallData.groups[groupIndex].connection
            });
            
            // Clear selection
            selectedTiles = [];
            score += 1;
            
            // Calculate and update new positions for ALL tiles
            let newPositionIndex = 0;
            
            // First, position all solved tiles (in order of groups solved)
            solvedGroups.forEach((group) => {
                group.tiles.forEach(tileId => {
                    const tile = wallTiles.find(t => t.id === tileId);
                    if (tile) {
                        tile.position = newPositionIndex;
                        newPositionIndex++;
                    }
                });
            });
            
            // Then, position all unsolved tiles
            wallTiles.forEach(tile => {
                if (!tile.solved) {
                    tile.position = newPositionIndex;
                    newPositionIndex++;
                }
            });
            
            // Now perform the animation by updating DOM without full re-render
            animateTilesToPositions();
            
            // Check if wall complete
            if (solvedGroups.length === 3) {
                // Auto-solve last group
                setTimeout(autoSolveLastGroup, 1000);
            }
            
            syncGameState();
            render();
        }

        function handleIncorrectGroup() {
            const remainingGroups = 4 - solvedGroups.length;
            
            if (remainingGroups === 2) {
                wallLives--;
                
                if (wallLives === 0) {
                    // Wall frozen
                    showWallFrozenModal = true;
                    stopTimer();
                }
            }
            
            selectedTiles = [];
            syncGameState();
            render();
        }

        function animateTilesToPositions() {
            // Get all tile elements
            const tileElements = document.querySelectorAll('.wall-tile');
            
            tileElements.forEach(element => {
                const tileId = element.getAttribute('data-tile-id');
                const tile = wallTiles.find(t => t.id === tileId);
                
                if (!tile) return;
                
                // Get current position
                const currentRect = element.getBoundingClientRect();
                const container = element.parentElement;
                const containerRect = container.getBoundingClientRect();
                
                // Calculate target position based on tile.position
                const targetRow = Math.floor(tile.position / 4);
                const targetCol = tile.position % 4;
                const targetTop = targetRow * 112;
                const targetLeft = `${targetCol * 25}%`;
                
                // Apply target position
                const oldTop = element.style.top;
                const oldLeft = element.style.left;
                
                element.style.top = targetTop + 'px';
                element.style.left = targetLeft;
                
                // Get new position in pixels
                const newRect = element.getBoundingClientRect();
                
                // Calculate the difference
                const deltaX = currentRect.left - newRect.left;
                const deltaY = currentRect.top - newRect.top;
                
                // Only animate if position actually changed
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    // Set transform to current position (before the style change)
                    element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    element.style.transition = 'none';
                    
                    // Force reflow
                    element.offsetHeight;
                    
                    // Animate to new position (which is now at 0,0 transform)
                    element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    element.style.transform = 'translate(0, 0)';
                }
                
                // Update solved class
                if (tile.solved) {
                    element.classList.add('solved', 'group-' + tile.solvedGroupIndex);
                    element.classList.remove('selected');
                }
            });
        }

        function autoSolveLastGroup() {
            const wallData = gameData.round3[0];
            
            // Find the one unsolved group
            for (let groupIndex = 0; groupIndex < 4; groupIndex++) {
                const alreadySolved = solvedGroups.some(g => g.groupIndex === groupIndex);
                
                if (!alreadySolved) {
                    const groupTiles = [];
                    
                    wallTiles.forEach((tile, index) => {
                        if (tile.groupIndex === groupIndex && !tile.solved) {
                            tile.solved = true;
                            tile.solvedGroupIndex = solvedGroups.length;
                            groupTiles.push(tile.text);
                        }
                    });
                    
                    if (groupTiles.length > 0) {
                        solvedGroups.push({
                            items: groupTiles.sort(),
                            connection: wallData.groups[groupIndex].connection,
                            groupIndex: groupIndex,
                            solvedGroupIndex: solvedGroups.length
                        });
                        
                        score += 1;
                        
                        // RECALCULATE tile positions before animating
                        recalculateWallPositions();
                        
                        // Update positions WITHOUT calling render() - let CSS animate!
                        updateTilePositionsInDOM();
                    }
                    break;
                }
            }
            
            if (isHost()) {
                syncGameState();
            }
        }
        
        function renderWall() {
            const remainingGroups = 4 - solvedGroups.length;
            const showLives = remainingGroups === 2 && wallPhase === 'solving' && wallTimerStarted;
            
            let html = '<div class="wall-header">';
            const hideButton = wallTimerStarted ? ' style="visibility: hidden;"' : '';
            
            // Back button (hidden during solving)
            if (wallPhase === 'setup') {
                html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToRounds()"> Back to Rounds</button>`;
            } else {
                html += '<div style="width: 150px;"></div>';
            }
            
            // Lives display
            if (showLives) {
                html += `<div class="lives-display">Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}</div>`;
            }
            
            html += '</div>';
            
            // Wall grid
            html += '<div class="wall-grid" style="position: relative; min-height: 440px;">';
            
            // Render each tile with calculated position
            wallTiles.forEach((tile) => {
                // Use tile.position directly (which was set during shuffle/rearrange)
                const pos = tile.position;
                const row = Math.floor(pos / 4);
                const col = pos % 4;
                
                // Calculate pixel positions (accounting for gaps)
                const tileWidth = 'calc((100% - 2.25rem) / 4)';
                const gapSize = 0.75; // rem
                const topPx = row * 100 + row * 12; // 100px height + 0.75rem gap (approx 12px)
                const leftCalc = `calc(${col} * ((100% - 2.25rem) / 4 + ${gapSize}rem))`;
                
                let classes = 'wall-tile';
                const isSelected = selectedTiles.includes(tile.id); // Use tile.id, not index
                
                // Add text-up class if this tile's group has a revealed connection
                const hasOverlay = tile.solved && wallPhase === 'guessing' && 
                                connectionGuesses[tile.solvedGroupIndex] && 
                                connectionGuesses[tile.solvedGroupIndex].revealed;
                if (hasOverlay) {
                    classes += ' text-up';
                }
                
                // Hide text until timer starts
                if (!wallTimerStarted) {
                    classes += ' hidden-text';
                }
                
                if (tile.solved) {
                    classes += ' solved group-' + tile.solvedGroupIndex;
                } else if (isSelected) {
                    classes += ' selected';
                } else if (wallPhase !== 'solving') {
                    classes += ' locked';
                }
                
                // For players, make tiles clickable; for host, tiles aren't directly clickable
                const canPlayerClick = isPlayer() && !tile.solved && wallPhase === 'solving' && wallTimerStarted && !timerStopped;
                const onclick = canPlayerClick ? `onclick="playerClicksTile(${tile.id})"` : '';

                const style = `top: ${topPx}px; left: ${leftCalc}; width: ${tileWidth};`;

                html += `<button class="${classes}" ${onclick} style="${style}" data-tile-id="${tile.id}">${tile.text}</button>`;
            });
            
            // In guessing phase, add overlays and buttons on the actual grid
            if (wallPhase === 'guessing') {
                solvedGroups.forEach((group, idx) => {
                    const row = idx;
                    const topPx = row * 100 + row * 12;
                    
                    // Connection overlay (appears in lower half of the row)
                    if (connectionGuesses[idx] && connectionGuesses[idx].revealed) {
                        const overlayTop = topPx + 50; // Start at middle of tile
                        const fadeInClass = connectionGuesses[idx].justRevealed ? ' fade-in' : '';
                        const displayStyle = connectionGuesses[idx].justRevealed ? '' : ' opacity: 1;';
                        html += `<div class="connection-display${fadeInClass}" style="top: ${overlayTop}px;${displayStyle}">${group.connection}</div>`;
                    }
                    
                    // Guess buttons (to the right of the row, side by side)
                    if (!connectionGuesses[idx] && isHost()) {
                        // Buttons side by side, centered vertically in the row
                        const buttonsTop = topPx + 27; // Center in 100px row (50px - 45px/2)
                        html += `<div style="position: absolute; right: -120px; top: ${buttonsTop}px; display: flex; gap: 0.5rem;">`;
                        html += `<button class="guess-btn correct" onclick="guessConnection(${idx}, true)"></button>`;
                        html += `<button class="guess-btn incorrect" onclick="guessConnection(${idx}, false)"></button>`;
                        html += '</div>';
                    }
                });
            }
            
            html += '</div>'; // Close wall-grid
            
            // Show timer or start button during solving phase
            if (wallPhase === 'setup' && isHost()) {
                html += '<div style="text-align: center; margin-top: 2rem;">';
                html += '<button class="btn btn-primary" onclick="startWallTimer()">Start Timer</button>';
                html += '</div>';
            } else if (wallPhase === 'solving') {
                html += '<div class="timer-bar-container" style="margin-top: 1rem;">';
                html += '<div id="timerBar" class="timer-bar"></div>';
                html += '<div id="timerText" class="timer-text">180s</div>';
                html += '</div>';
            }
            
            // Continue button after all guessed
            if (wallPhase === 'guessing' && Object.keys(connectionGuesses).length === solvedGroups.length && isHost()) {
                html += '<div style="text-align: center; margin-top: 2rem;">';
                html += '<button class="btn btn-primary" onclick="selectRound(3)">Continue to Missing Vowels</button>';
                html += '</div>';
            }
            
            // Time up modal
            if (showTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content">';
                html += '<div class="time-up-title">Time is Up</div>';
                if (isHost()) {
                    html += '<button class="btn btn-primary" onclick="resolveWallTimeout()">Resolve Wall</button>';
                }
                html += '</div>';
                html += '</div>';
            }
            
            // Wall frozen modal
            if (showWallFrozenModal) {
                html += '<div class="wall-frozen-modal">';
                html += '<div class="wall-frozen-content">';
                html += '<div class="wall-frozen-title">The Wall has Frozen!</div>';
                if (isHost()) {
                    html += '<button class="btn btn-primary" onclick="resolveWallFrozen()">Resolve Wall</button>';
                }
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function guessConnection(groupIndex, isCorrect) {
            if (!isHost()) return;
            
            // Mark this specific guess with revealed flag (no justRevealed flag needed)
            connectionGuesses[groupIndex] = { 
                correct: isCorrect, 
                revealed: true
            };
            
            if (isCorrect) score += 1;
            
            // Check for bonus
            if (Object.keys(connectionGuesses).length === 4) {
                const allCorrect = Object.values(connectionGuesses).every(v => v.correct);
                const allFound = solvedGroups.every(g => !g.autoSolved);
                
                if (allCorrect && allFound) {
                    score += 2; // Bonus points
                }
            }
            
            syncGameState();
            render();
        }

        function renderWallTimeUpModal() {
            let html = '<div class="time-up-modal">';
            html += '<div class="time-up-content">';
            html += '<div class="time-up-title">Time is Up</div>';
            if (isHost()) {
                html += '<button class="btn btn-primary" onclick="resolveWallTimeout()">Resolve Wall</button>';
            }
            html += '</div></div>';
            return html;
        }

        function renderWallFrozenModal() {
            let html = '<div class="wall-frozen-modal">';
            html += '<div class="wall-frozen-content">';
            html += '<div class="wall-frozen-title">The Wall has Frozen!</div>';
            if (isHost()) {
                html += '<button class="btn btn-primary" onclick="resolveWallFrozen()">Resolve Wall</button>';
            }
            html += '</div></div>';
            return html;
        }

        function resolveWallTimeout() {
            if (!isHost()) return;
            showTimeUpModal = false;
            
            autoSolveRemainingGroups();
            
            // Sync immediately so players' modals disappear
            syncGameState();
        }

        function resolveWallFrozen() {
            if (!isHost()) return;
            showWallFrozenModal = false;
            
            autoSolveRemainingGroups();
            
            // Sync immediately so players' modals disappear
            syncGameState();
        }

        function autoSolveRemainingGroups() {
            const wallData = gameData.round3[0];
            
            // Find all unsolved groups and mark them
            for (let groupIndex = 0; groupIndex < 4; groupIndex++) {
                const alreadySolved = solvedGroups.some(g => g.groupIndex === groupIndex);
                
                if (!alreadySolved) {
                    const groupTiles = [];
                    
                    wallTiles.forEach((tile, index) => {
                        if (tile.groupIndex === groupIndex && !tile.solved) {
                            tile.solved = true;
                            tile.solvedGroupIndex = solvedGroups.length;
                            groupTiles.push(tile.text);
                        }
                    });
                    
                    if (groupTiles.length > 0) {
                        solvedGroups.push({
                            items: groupTiles.sort(),
                            connection: wallData.groups[groupIndex].connection,
                            groupIndex: groupIndex,
                            solvedGroupIndex: solvedGroups.length,
                            autoSolved: true
                        });
                    }
                }
            }
            
            // RECALCULATE tile positions before animating
            recalculateWallPositions();
            
            // Update positions WITHOUT calling render() - let CSS animate!
            updateTilePositionsInDOM();
            
            // Wait for animations to complete, then move to guessing phase
            setTimeout(() => {
                wallPhase = 'guessing';
                if (isHost()) {
                    syncGameState();
                }
                render(); // Now we can render for guessing phase
            }, 1000);
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Render functions
        function renderSetupModal() {
            if (!showSetupModal) return '';
            
            if (setupStep === 'initial') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Only Connect</div>
                            <button class="setup-btn" onclick="showHostPassword()">New Game (Host)</button>
                            <button class="setup-btn" onclick="showJoinGame()">Join Game (Player)</button>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'hostPassword') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Host Verification</div>
                            <p style="color: white; margin-bottom: 1rem; font-size: 0.875rem;">Enter production password to continue</p>
                            <input type="password" 
                                   id="passwordInput" 
                                   class="setup-input" 
                                   placeholder="Password" 
                                   onkeypress="if(event.key === 'Enter') verifyHostPassword()">
                            <button class="setup-btn" onclick="verifyHostPassword()">Verify</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'createGame') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Host Options</div>
                            <input type="text" 
                                id="gameCodeInput" 
                                class="setup-input" 
                                placeholder="Enter game code (e.g., Veto2)" 
                                onkeypress="if(event.key === 'Enter') createGame()">
                            <button class="setup-btn" onclick="createGame()">Create Game</button>
                            <button class="setup-btn" onclick="joinAsSecondaryHostWithCode()">Join as Secondary Host</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'joinGame') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Join Game</div>
                            <input type="text" 
                                   id="joinCodeInput" 
                                   class="setup-input" 
                                   placeholder="Enter game code" 
                                   onkeypress="if(event.key === 'Enter') proceedToName()">
                            <button class="setup-btn" onclick="proceedToName()">Next</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'enterName') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Enter Your Name</div>
                            <input type="text" 
                                   id="playerNameInput" 
                                   class="setup-input" 
                                   placeholder="Your name" 
                                   onkeypress="if(event.key === 'Enter') joinGame()">
                            <button class="setup-btn" onclick="joinGame()">Join Game</button>
                            <button class="setup-btn" onclick="setupStep = 'joinGame'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            }
        }

        function showHostPassword() {
            setupStep = 'hostPassword';
            render();
            setTimeout(() => {
                const input = document.getElementById('passwordInput');
                if (input) input.focus();
            }, 100);
        }

        function verifyHostPassword() {
            const input = document.getElementById('passwordInput');
            const password = input ? input.value : '';
            const correctPassword = 'Haych22'; // Change this to your desired password
            
            if (password === correctPassword) {
                showCreateGame();
            } else {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Incorrect password. Access denied.';
                setTimeout(() => {
                    setupStep = 'initial';
                    render();
                }, 2000);
            }
        }

        function showCreateGame() {
            setupStep = 'createGame';
            render();
            setTimeout(() => {
                const input = document.getElementById('gameCodeInput');
                if (input) input.focus();
            }, 100);
        }

        function showJoinGame() {
            setupStep = 'joinGame';
            render();
            setTimeout(() => {
                const input = document.getElementById('joinCodeInput');
                if (input) input.focus();
            }, 100);
        }

        function joinAsSecondaryHostWithCode() {
            const input = document.getElementById('gameCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            joinAsSecondaryHostInFirebase(code);
        }

        function createGame() {
            const input = document.getElementById('gameCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            createGameInFirebase(code);
        }

        function proceedToName() {
            const input = document.getElementById('joinCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            gameCode = code;
            setupStep = 'enterName';
            render();
            
            setTimeout(() => {
                const nameInput = document.getElementById('playerNameInput');
                if (nameInput) nameInput.focus();
            }, 100);
        }

        function joinGame() {
            const input = document.getElementById('playerNameInput');
            const name = input ? input.value.trim() : '';
            
            if (!name) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter your name';
                return;
            }
            
            joinGameInFirebase(gameCode, name);
        }

        function renderRoundSelector() {
            let html = `
                <div class="round-selector">
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(0)">
                        <div class="round-title">Round 1</div>
                        <div>Connections</div>
                    </button>
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(1)">
                        <div class="round-title">Round 2</div>
                        <div>Sequences</div>
                    </button>
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(2)">
                        <div class="round-title">Round 3</div>
                        <div>Connecting Wall</div>
                    </button>
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(3)">
                        <div class="round-title">Round 4</div>
                        <div>Missing Vowels</div>
                    </button>
                </div>
            `;
            
            // Audio Tester (only for hosts)
            if (isHost() || isSecondaryHost()) {
                html += '<div style="margin-top: 2rem; background: rgba(30, 30, 30, 0.9); border: 2px solid rgba(80, 80, 80, 1); border-radius: 0.5rem; padding: 1.5rem;">';
                html += '<div style="color: white; font-size: 1.125rem; font-weight: bold; margin-bottom: 1rem; text-align: center;">Audio Level Tester</div>';
                
                // Audio player container
                html += '<div style="background: rgba(255, 255, 255, 0.1); border-radius: 0.5rem; padding: 1.5rem; margin-bottom: 1rem; min-height: 100px; display: flex; align-items: center; justify-content: center;">';
                
                if (audioTesterPlaying && !audioTesterPaused) {
                    // Show playing audio with iframe
                    const embedUrl = 'https://www.youtube.com/watch?v=psweizZGx44&list=RDpsweizZGx44&start_radio=1&pp=ygUPc2lzc2FsIGluZmluaXR5oAcB';
                    html += `
                        <div style="position: relative; width: 100%; height: 100%;">
                            <iframe 
                                id="audio-tester-iframe"
                                width="1" 
                                height="1" 
                                src="${embedUrl}" 
                                frameborder="0" 
                                allow="autoplay; encrypted-media" 
                                style="opacity: 0; position: absolute;">
                            </iframe>
                            <div style="font-size: 3rem;"></div>
                        </div>
                    `;
                } else {
                    html += '<div style="font-size: 3rem; color: rgba(255, 255, 255, 0.5);"></div>';
                }
                
                html += '</div>';
                
                // Control buttons
                html += '<div style="display: flex; gap: 1rem; justify-content: center;">';
                
                if (!audioTesterPlaying) {
                    // Show Play button when stopped
                    html += `<button class="btn btn-primary ${!isHost() ? 'disabled' : ''}" onclick="playAudioTester()" style="width: 120px;"> Play</button>`;
                } else if (audioTesterPaused) {
                    // Show Resume button when paused
                    html += `<button class="btn btn-primary ${!isHost() ? 'disabled' : ''}" onclick="playAudioTester()" style="width: 120px;"> Resume</button>`;
                } else {
                    // Show Pause button when playing
                    html += `<button class="btn btn-primary ${!isHost() ? 'disabled' : ''}" onclick="pauseAudioTester()" style="width: 120px;"> Pause</button>`;
                }
                
                html += `<button class="btn btn-incorrect ${!isHost() ? 'disabled' : ''}" onclick="stopAudioTester()" style="width: 120px;"> Stop</button>`;
                html += '</div>';
                
                html += '<div style="color: rgba(255, 255, 255, 0.7); font-size: 0.875rem; text-align: center; margin-top: 1rem;">Adjust your audio levels before starting the game</div>';
                html += '</div>';
            }
            
            return html;
        }

        function renderQuestionSelector() {
            const questions = currentRound === 0 ? gameData.round1 : gameData.round2;
            const roundName = currentRound === 0 ? "Round 1: Connections" : "Round 2: Sequences";
            const exampleKey = `r${currentRound}qExample`;
            const exampleCompleted = completedQuestions.includes(exampleKey);
            
            let html = `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">`;
            html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToRounds()"> Back to Rounds</button>`;
            html += `<div style="color: white; font-size: 1.25rem; font-weight: 600;">${roundName}</div>`;
            html += `<div style="width: 150px;"></div>`;
            html += `</div>`;
            
            // Example question box (above the grid)
            const canSelectExample = isHost() && !exampleCompleted && sequentialQuestionIndex === 0;
            const exampleDisabled = !canSelectExample ? 'disabled' : '';
            html += `<div style="margin-bottom: 1.5rem;">`;
            html += `<button class="question-btn ${exampleCompleted ? 'completed' : ''} ${exampleDisabled}" ${canSelectExample ? `onclick="selectQuestion('example')"` : ''} style="width: 100%;">Example Question</button>`;
            html += `</div>`;
            
            html += '<div class="question-grid">';
            for (let i = 0; i < questions.length; i++) {
                const questionKey = `r${currentRound}q${i}`;
                const completed = completedQuestions.includes(questionKey);
                const isNextQuestion = (i === sequentialQuestionIndex);
                const canSelect = isHost() && isNextQuestion && !completed;
                const disabled = !canSelect ? 'disabled' : '';
                html += `<button class="question-btn ${completed ? 'completed' : ''} ${disabled}" ${canSelect ? `onclick="selectQuestion(${i})"` : ''}>Q${i + 1}</button>`;
            }
            html += '</div>';
            return html;
        }

        function renderClues() {
            // Safety check
            if (currentQuestion === null || currentQuestion === undefined) {
                console.error('DEBUG renderClues called with null/undefined currentQuestion');
                return '<div style="color: white; text-align: center; margin-top: 2rem;">Loading question...</div>';
            }
            
            const isSequence = currentRound === 1;
            const isExample = currentQuestion === 'example';
            
            let question;
            if (isExample) {
                question = isSequence ? gameData.exampleRound2 : gameData.exampleRound1;
            } else {
                question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            }
            
            // Additional safety check
            if (!question) {
                console.error('DEBUG renderClues - question not found for currentQuestion:', currentQuestion, 'currentRound:', currentRound);
                return '<div style="color: white; text-align: center; margin-top: 2rem;">Question not found...</div>';
            }
            const pointsValues = question.points;
            
            let html = '';
            const hideButton = cluesRevealed > 0 ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToQuestions()"${hideButton}> Back to Questions</button>`;
            html += '<div class="clue-container"><div class="clue-grid">';
            
            for (let i = 0; i < 4; i++) {
                html += '<div class="clue-wrapper">';
                
                let showTimerOnThisClue;
                if (timerStopped && timerStoppedOnClue !== null) {
                    showTimerOnThisClue = (i === timerStoppedOnClue);
                } else {
                    showTimerOnThisClue = isSequence ? (i === cluesRevealed - 1 && cluesRevealed > 0 && i < 3) : (i === cluesRevealed - 1 && cluesRevealed > 0);
                }
                
                if (showTimerOnThisClue) {
                    html += `<div class="points-label">${pointsValues[i]} Point${pointsValues[i] !== 1 ? 's' : ''}</div>`;
                    html += `<div class="timer-bar-container"><div class="timer-bar" id="timerBar-${i}" style="width: 100%;"></div><div class="timer-text" id="timerText-${i}">60s</div></div>`;
                } else {
                    html += '<div class="timer-spacer"></div>';
                }
                
                const revealed = i < cluesRevealed;
                // Allow clue 4 to be clicked once buzzer is pressed (timerStopped means someone buzzed)
                const canReveal = isSequence ? (i < 3 || timerStopped) : true;
                
                // Handle different clue types (text, image, audio)
                let clueText = '';
                if (revealed) {
                    const clue = question.clues[i];
                    
                    // Check if clue is an object (image or audio) or plain text
                    if (typeof clue === 'object' && clue !== null && clue.type === 'image') {
                        clueText = `<img src="${clue.src}" alt="${clue.alt || 'Clue image'}" style="max-width: 90%; max-height: 90%; object-fit: contain;">`;
                    } else if (typeof clue === 'object' && clue !== null && clue.type === 'audio') {
                        const videoId = clue.youtube;
                        const startTime = clue.start || 0;
                        const duration = clue.duration || null;
                        
                        // Determine if this audio should actually play
                        // Only play if: it's the most recent clue revealed, answer isn't revealed yet, timer is running
                        const shouldAutoplay = (i === cluesRevealed - 1) && !answerRevealed && !timerStopped && !showCluesTimeUpModal;
                        
                        // Build YouTube URL parameters
                        let embedUrl = `https://www.youtube.com/embed/${videoId}?${shouldAutoplay ? 'autoplay=1&' : ''}start=${startTime}`;
                        
                        if (duration) {
                            const endTime = startTime + duration;
                            embedUrl += `&end=${endTime}`;
                        }
                        
                        // Check if we should show the title (only after host clicks or answer revealed)
                        const titleKey = `${currentRound}-${currentQuestion}-${i}`;
                        const hostClickedToReveal = window._audioTitlesRevealed && window._audioTitlesRevealed[titleKey];
                        const showTitle = hostClickedToReveal || answerRevealed;
                        
                        // For players: show only music icon (NO audio iframe)
                        if (isPlayer()) {
                            if (showTitle) {
                                // Show title after buzzer/timeout
                                clueText = `
                                    <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 0.5rem;">
                                        <div style="font-size: 2rem;"></div>
                                        <div style="font-size: 0.875rem;">${clue.title || 'Audio Clue'}</div>
                                    </div>
                                `;
                            } else {
                                // Just music icon - NO iframe for players
                                clueText = `
                                    <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 0.5rem;">
                                        <div style="font-size: 2rem;"></div>
                                    </div>
                                `;
                            }
                        } else if (isHost() || isSecondaryHost()) {
                            // For hosts (main and secondary): show audio with iframe
                            const titleOpacity = showTitle ? '1' : '0.3';
                            const titleColor = showTitle ? 'white' : '#94a3b8';
                            
                            clueText = `
                                <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 0.5rem; position: relative;">
                                    ${!showTitle ? `<iframe 
                                        id="audio-clue-${i}"
                                        width="1" 
                                        height="1" 
                                        src="${embedUrl}" 
                                        frameborder="0" 
                                        allow="autoplay; encrypted-media" 
                                        style="opacity: 0; position: absolute;">
                                    </iframe>` : ''}
                                    <div style="font-size: 2rem;"></div>
                                    <div style="font-size: 0.875rem; opacity: ${titleOpacity}; color: ${titleColor};">${clue.title || 'Audio Clue'}</div>
                                </div>
                            `;
                        } else {
                            // For host: always show title with transparency, allow clicking to toggle visibility
                            const titleOpacity = showTitle ? '1' : '0.3';
                            const titleColor = showTitle ? 'white' : '#94a3b8';
                            
                            clueText = `
                                <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 0.5rem; position: relative;">
                                    ${!showTitle ? `<iframe 
                                        id="audio-clue-${i}"
                                        width="1" 
                                        height="1" 
                                        src="${embedUrl}" 
                                        frameborder="0" 
                                        allow="autoplay; encrypted-media" 
                                        style="opacity: 0; position: absolute;">
                                    </iframe>` : ''}
                                    <div style="font-size: 2rem;"></div>
                                    <div style="font-size: 0.875rem; opacity: ${titleOpacity}; color: ${titleColor};">${clue.title || 'Audio Clue'}</div>
                                </div>
                            `;
                        }
                    } else {
                        // Plain text clue - handle both string and object that might be text
                        clueText = typeof clue === 'string' ? clue : (clue || '');
                    }
                } else {
                    // When not revealed, show nothing to players but show transparent preview to host
                    if (isHost()) {
                        const clue = question.clues[i];
                        
                        if (typeof clue === 'object' && clue !== null && clue.type === 'image') {
                            clueText = `<div style="opacity: 0.3;"><img src="${clue.src}" alt="${clue.alt || 'Clue image'}" style="max-width: 90%; max-height: 90%; object-fit: contain;"></div>`;
                        } else if (typeof clue === 'object' && clue !== null && clue.type === 'audio') {
                            clueText = `<div style="opacity: 0.3; color: #94a3b8;"> ${clue.title || 'Audio Clue'}</div>`;
                        } else {
                            const textClue = typeof clue === 'string' ? clue : '';
                            clueText = `<div style="opacity: 0.3; color: #94a3b8;">${textClue}</div>`;
                        }
                    } else {
                        clueText = '';
                    }
                }
                
                // Allow clicking audio clues after buzzer/timeout to show title to players
                const isAudioClue = typeof question.clues[i] === 'object' && question.clues[i] !== null && question.clues[i].type === 'audio';
                const canClickToShowTitle = isAudioClue && revealed && (timerStopped || showCluesTimeUpModal) && !answerRevealed && isHost();
                
                const classes = 'clue-btn' + (revealed ? ' revealed' : '') + (!isHost() ? ' disabled' : '');
                
                const canClickThisClue = isSequence 
                    ? (i === cluesRevealed && canReveal && isHost()) || (i === 3 && timerStopped && !revealed && isHost()) || canClickToShowTitle
                    : (i === cluesRevealed && canReveal && isHost()) || canClickToShowTitle;
                
                const onclick = canClickThisClue ? (canClickToShowTitle ? `onclick="showAudioTitle(${i})"` : `onclick="revealClue(${i})"`) : '';
        
                html += `<button class="${classes}" ${onclick}>${clueText}</button>`;
                html += '</div>';
            }
            html += '</div>';
            
            const answerText = isSequence ? question.answer : question.connection;
            const subtitle = isSequence ? question.sequence : '';
            html += '<div class="answer-box">';
            if (answerRevealed) {
                if (isSequence) {
                    html += `<div style="font-size: 1.25rem; font-weight: bold;">${subtitle}</div>`;
                } else {
                    html += `<div style="font-size: 1.25rem; font-weight: bold;">${answerText}</div>`;
                }
            } else if (isHost() && cluesRevealed > 0) {
                // Show answer to host only, with transparency
                let displayAnswer = isSequence ? subtitle : answerText;
                
                // Make sure we're displaying a string, not an object
                if (typeof displayAnswer === 'object') {
                    displayAnswer = '';
                }
                
                html += `<div style="font-size: 1.25rem; font-weight: bold; opacity: 0.3; color: #94a3b8;">${displayAnswer}</div>`;
            }
            html += '</div>';
            
            const buttonContainerClass = !isHost() || isSecondaryHost() ? 'buttons-container player-hidden' : 'buttons-container';
            html += `<div class="${buttonContainerClass}">`;
            if (timerStopped && !answerRevealed) {
                html += '<div class="button-row">';
                html += `<button class="btn btn-correct ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markCorrect()">Correct</button>`;
                html += `<button class="btn btn-incorrect ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markIncorrect()">Incorrect</button>`;
                html += '</div>';
            }
            if (answerRevealed) {
                html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="completeQuestion()">Continue</button>`;
            }
            html += '</div>';
            
            // Timeout modal for Connections/Sequence rounds
            if (showCluesTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 200px;">';
                html += '<div class="time-up-title">Time is Up</div>';
                
                // Only show button for host
                if (isHost()) {
                    html += '<button class="btn btn-primary" onclick="dismissTimeUpModal()" style="font-size: 1.25rem; padding: 1rem 2rem; margin-top: 1.5rem;">Continue</button>';
                }
                
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function renderVowels() {
            const category = gameData.round4[vowelsCurrentCategory];
            const clue = category.clues[vowelsCurrentClue];
            
            let html = '';
            const hideButton = vowelsCategoryRevealed ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToRounds()"${hideButton}> Back to Rounds</button>`;
            
            // Timer bar - always visible, same position as wall timer
            html += '<div class="timer-bar-container"><div id="timerBar" class="timer-bar" style="width: 100%;"></div><div id="timerText" class="timer-text">120s</div></div>';
            
            // Check if current category is complete (all clues answered)
            const categoryComplete = vowelsCurrentClue === category.clues.length - 1 && vowelsAnswerRevealed;
            const isLastCategory = vowelsCurrentCategory === gameData.round4.length - 1;
            const canAdvanceCategory = categoryComplete && !isLastCategory;
            
            // Category box - clickable only for first category reveal
            const categoryDisabled = vowelsCategoryAnimating || vowelsCategoryRevealed || !isHost();
            const categoryClasses = 'vowels-category-box' + (categoryDisabled ? ' disabled' : '');
            const categoryOnclick = !vowelsCategoryRevealed && isHost() ? ' onclick="revealCategoryAndStartTimer()"' : '';
            const categoryText = vowelsCategoryRevealed ? category.category : '';
            html += `<div class="${categoryClasses}"${categoryOnclick}>${categoryText}</div>`;

            html += '<div class="vowels-clue-box">';
            if (vowelsClueRevealed) {
                if (vowelsAnswerRevealed) {
                    html += createAnimatedClueText(clue.withoutVowels, clue.answer, true);
                } else {
                    html += `<div class="vowels-clue-text">${clue.withoutVowels}</div>`;
                    // Show answer to host only with transparency
                    if (isHost()) {
                        html += `<div style="font-size: 1.5rem; opacity: 0.3; color: #94a3b8; margin-top: 1rem;">${clue.answer}</div>`;
                    }
                }
            }
            html += '</div>';
            
            const buttonContainerClass = !isHost() || isSecondaryHost() ? 'buttons-container player-hidden' : 'buttons-container';
            html += `<div class="${buttonContainerClass}">`;
            
            // Show Correct/Incorrect buttons when timer is stopped and answer not revealed
            if (timerStopped && !vowelsAnswerRevealed && buzzedInPlayer) {
                html += '<div class="button-row">';
                html += `<button class="btn btn-correct ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markVowelsCorrect()">Correct</button>`;
                html += `<button class="btn btn-incorrect ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markVowelsIncorrect()">Incorrect</button>`;
                html += '</div>';
            } 
            // After answer is revealed
            else if (vowelsAnswerRevealed) {
                // Check if there are more clues in this category
                if (vowelsCurrentClue < category.clues.length - 1) {
                    // More clues in this category - show Next Clue button
                    html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="nextVowelsClue()">Next Clue</button>`;
                } else if (canAdvanceCategory) {
                    // Finished this category, but more categories exist - show Next Category button
                    html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="nextVowelsCategory()">Next Category</button>`;
                } else if (isLastCategory && categoryComplete) {
                    // Finished last category - show End Game button
                    html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="endGame()">End Game</button>`;
                }
            }
            
            html += '</div>';
            
            // Time up modal
            if (vowelsShowTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content">';
                html += '<div class="time-up-title">Time is Up</div>';
                html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="revealVowelsAnswerFromModal()" style="font-size: 1.25rem; padding: 1rem 2rem;">End Game</button>`;
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function renderFinalScore() {
            if (showStatsView) {
                return renderStatsView();
            }
            
            return `
                <div class="final-score-container">
                    <div class="final-score-names">${playerNames}</div>
                    <div class="final-score-box">
                        <div class="final-score-value">${score}</div>
                    </div>
                    ${isHost() ? '<button class="end-session-btn" onclick="viewStats()" style="margin-bottom: 1rem;">View Player Statistics</button>' : ''}
                    <button class="end-session-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="endSession()">End Session</button>
                </div>
            `;
        }

        function renderStatsView() {
            let html = '<div class="final-score-container" style="max-width: 900px; margin: 0 auto;">';
            html += '<div class="final-score-names" style="margin-bottom: 2rem;">Player Statistics</div>';
            
            // Create table
            html += '<div style="background: rgba(30, 30, 30, 0.9); border: 2px solid rgba(80, 80, 80, 1); border-radius: 0.5rem; padding: 2rem; color: white; margin-bottom: 2rem;">';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            
            // Header
            html += '<thead><tr style="border-bottom: 2px solid rgba(255, 255, 255, 0.3);">';
            html += '<th style="padding: 1rem; text-align: left; font-size: 1.125rem;">Player</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">Total</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">R1</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">R2</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">R4</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">5pt</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">3pt</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">2pt</th>';
            html += '<th style="padding: 1rem; text-align: center; font-size: 1.125rem;">1pt</th>';
            html += '</tr></thead>';
            
            // Body
            html += '<tbody>';
            
            // Sort players by total points (descending)
            const sortedPlayers = Object.entries(playerStats).sort((a, b) => b[1].total - a[1].total);
            
            sortedPlayers.forEach(([playerName, stats], index) => {
                const rowStyle = index % 2 === 0 ? 'background: rgba(255, 255, 255, 0.05);' : '';
                html += `<tr style="${rowStyle}">`;
                html += `<td style="padding: 0.75rem; font-weight: bold;">${playerName}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center; font-weight: bold; font-size: 1.25rem; color: #fbbf24;">${stats.total}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center;">${stats.round1}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center;">${stats.round2}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center;">${stats.round4}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center; color: #22c55e;">${stats.points5}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center; color: #3b82f6;">${stats.points3}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center; color: #a855f7;">${stats.points2}</td>`;
                html += `<td style="padding: 0.75rem; text-align: center; color: #94a3b8;">${stats.points1}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += '</div>';
            
            // Back and End Session buttons
            html += '<div style="display: flex; gap: 1rem; justify-content: center;">';
            html += '<button class="end-session-btn" onclick="closeStats()" style="margin: 0;">Back to Score</button>';
            html += '<button class="end-session-btn" onclick="endSession()" style="margin: 0;">End Session</button>';
            html += '</div>';
            
            html += '</div>';
            return html;
        }

        function recalculateWallPositions() {
            let newPositionIndex = 0;
            
            // First, assign positions to all solved tiles (in order of when groups were solved)
            solvedGroups.forEach((group) => {
                // For each group, assign positions to its tiles
                group.items.forEach(itemText => {
                    const tile = wallTiles.find(t => t.text === itemText);
                    if (tile) {
                        tile.position = newPositionIndex;
                        newPositionIndex++;
                    }
                });
            });
            
            // Then, assign positions to all unsolved tiles
            wallTiles.forEach(tile => {
                if (!tile.solved) {
                    tile.position = newPositionIndex;
                    newPositionIndex++;
                }
            });
        }
        
        function updateTilePositionsInDOM() {
            // Get all tile elements
            const tileElements = document.querySelectorAll('.wall-tile');
            
            tileElements.forEach(element => {
                const tileId = parseInt(element.getAttribute('data-tile-id'));
                const tile = wallTiles.find(t => t.id === tileId);
                
                if (!tile) return;
                
                // Calculate NEW target position based on tile.position
                const targetRow = Math.floor(tile.position / 4);
                const targetCol = tile.position % 4;
                const targetTop = targetRow * 112;
                const targetLeft = `${targetCol * 25}%`;
                
                // Get CURRENT position in the DOM (before we change it)
                const currentTop = element.style.top;
                const currentLeft = element.style.left;
                
                // Parse current position to compare
                const currentTopPx = parseInt(currentTop) || 0;
                const currentLeftPercent = parseFloat(currentLeft) || 0;
                const targetLeftPercent = targetCol * 25;
                
                // Check if position actually changed
                const positionChanged = (currentTopPx !== targetTop) || (Math.abs(currentLeftPercent - targetLeftPercent) > 0.1);
                
                if (positionChanged) {
                    // Get pixel positions for animation calculation
                    const currentRect = element.getBoundingClientRect();
                    
                    // Apply NEW position
                    element.style.top = targetTop + 'px';
                    element.style.left = targetLeft;
                    
                    // Get NEW position in pixels (after style change)
                    const newRect = element.getBoundingClientRect();
                    
                    // Calculate the difference
                    const deltaX = currentRect.left - newRect.left;
                    const deltaY = currentRect.top - newRect.top;
                    
                    // Animate from old position to new position
                    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                        // Set transform to OLD position (creates illusion tile hasn't moved yet)
                        element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        element.style.transition = 'none';
                        
                        // Force reflow
                        element.offsetHeight;
                        
                        // Animate to NEW position (transform to 0,0)
                        element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        element.style.transform = 'translate(0, 0)';
                    }
                } else {
                    // Position didn't change, just ensure it's set correctly
                    element.style.top = targetTop + 'px';
                    element.style.left = targetLeft;
                }
                
                // Update solved class
                if (tile.solved) {
                    element.classList.add('solved', 'group-' + tile.solvedGroupIndex);
                    element.classList.remove('selected');
                }
            });
            
            // Update score display
            const scoreElement = document.querySelector('.score-value');
            if (scoreElement) scoreElement.textContent = score;
        }

            function updateWallStateWithoutRender() {
                // Update score display
                const scoreElement = document.querySelector('.score-value');
                if (scoreElement) scoreElement.textContent = score;
                
                // Update tiles in DOM (selection state and visibility)
                document.querySelectorAll('.wall-tile').forEach(element => {
                    const tileId = parseInt(element.getAttribute('data-tile-id'));
                    const isSelected = selectedTiles.includes(tileId);
                    
                    // Update selection state
                    if (isSelected) {
                        element.classList.add('selected');
                    } else {
                        element.classList.remove('selected');
                    }
                    
                    // Update text visibility based on whether timer has started
                    if (wallTimerStarted) {
                        element.classList.remove('hidden-text');
                    } else {
                        element.classList.add('hidden-text');
                    }
                });
                
                // Update lives display if needed
                const remainingGroups = 4 - solvedGroups.length;
                const showLives = remainingGroups === 2 && wallPhase === 'solving' && wallTimerStarted;
                
                if (showLives) {
                    const wallHeader = document.querySelector('.wall-header');
                    let livesDisplay = wallHeader?.querySelector('.lives-display');
                    
                    if (wallHeader && !livesDisplay) {
                        const livesHtml = `<div class="lives-display">Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}</div>`;
                        wallHeader.insertAdjacentHTML('beforeend', livesHtml);
                    } else if (livesDisplay) {
                        livesDisplay.innerHTML = `Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}`;
                    }
                }
                
                // Update timer display
                if (timerRemainingWhenStopped !== null) {
                    updateTimerDisplay(timerRemainingWhenStopped);
                }
                
                // Handle modals
                if (showWallFrozenModal && !document.querySelector('.wall-frozen-modal')) {
                    const gameContainer = document.querySelector('.game-container');
                    if (gameContainer) {
                        const modalHtml = `
                            <div class="wall-frozen-modal">
                                <div class="wall-frozen-content">
                                    <div class="wall-frozen-title">The Wall has Frozen!</div>
                                </div>
                            </div>
                        `;
                        gameContainer.insertAdjacentHTML('beforeend', modalHtml);
                    }
                }
                
                if (showTimeUpModal && !document.querySelector('.time-up-modal')) {
                    const gameContainer = document.querySelector('.game-container');
                    if (gameContainer) {
                        const modalHtml = `
                            <div class="time-up-modal">
                                <div class="time-up-content">
                                    <div class="time-up-title">Time is Up</div>
                                </div>
                            </div>
                        `;
                        gameContainer.insertAdjacentHTML('beforeend', modalHtml);
                    }
                }
            }
            
            // Update score display
            const scoreElement = document.querySelector('.score-value');
            if (scoreElement) scoreElement.textContent = score;
            
            // Update lives display if needed
            const remainingGroups = 4 - solvedGroups.length;
            if (remainingGroups === 2 && wallPhase === 'solving' && wallTimerStarted) {
                const wallHeader = document.querySelector('.wall-header');
                const existingLives = wallHeader?.querySelector('.lives-display');
                
                if (wallHeader && !existingLives) {
                    const livesHtml = `<div class="lives-display">Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}</div>`;
                    wallHeader.insertAdjacentHTML('beforeend', livesHtml);
                } else if (existingLives) {
                    existingLives.innerHTML = `Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}`;
                }
            }

        function render() {
            const container = document.getElementById('gameContainer');
            let content = '';

            console.log('DEBUG render() - view:', view, 'currentRound:', currentRound, 'currentQuestion:', currentQuestion);
            
            if (view === 'rounds') content = renderRoundSelector();
            else if (view === 'questions') content = renderQuestionSelector();
            else if (view === 'clues' && currentQuestion !== null) content = renderClues();
            else if (view === 'wall') content = renderWall();
            else if (view === 'vowels') content = renderVowels();
            else if (view === 'finalScore') content = renderFinalScore();
            else {
                // Fallback if view/question state is invalid
                console.warn('DEBUG Invalid view state - view:', view, 'currentQuestion:', currentQuestion);
                content = '<div style="color: white; text-align: center; margin-top: 2rem;">Loading...</div>';
            }
            
            const headerHtml = view === 'finalScore' ? '' : `
                <div class="header-card">
                    <h1 class="header-title">${playerNames}</h1>
                    <div class="score-box">
                        <div class="score-value">${score}</div>
                    </div>
                </div>
            `;

            // Buzzer indicator (fixed position overlay, doesn't displace content)
            const buzzedIndicator = buzzedInPlayer ? `
                <div style="position: fixed; top: 275px; left: 50%; transform: translateX(-50%); z-index: 999;">
                    <span class="buzzed-indicator">${buzzedInPlayer} buzzed in!</span>
                </div>
            ` : '';
            
            let categoryHtml = '';
            if (currentCategoryName && view !== 'rounds' && view !== 'questions' && view !== 'finalScore') {
                let displayText = currentCategoryName;
                
                // Add question number for Connections and Sequences rounds
                if (view === 'clues' && currentQuestion !== null) {
                    displayText += `<br>Question ${currentQuestion + 1}`;
                }
                
                categoryHtml = `<div class="category-display">${displayText}</div>`;
            }
            
            const setupModalHtml = renderSetupModal();
            
            container.innerHTML = `
                <div class="game-container">
                    ${headerHtml}
                    ${categoryHtml}
                    ${buzzedIndicator}
                    ${content}
                </div>
                ${setupModalHtml}
            `;
            
            if (view === 'clues' && timerStartTime !== null) updateTimer();
            if (view === 'wall' && wallPhase === 'solving' && timerStartTime !== null) updateTimer();
            if (view === 'vowels' && timerStartTime !== null) updateTimer();

            // After render, update timer display if it's stopped
            if (timerStopped && timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            }
        }

        // Clean up game when host closes window
        window.addEventListener('beforeunload', () => {
            if (isHost() && gameCode && gameRef) {
                gameRef.remove();
            }
        });
        
        // Initialize
        render();
    </script>
</body>
</html>
