<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBH Only Connect</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: linear-gradient(to bottom right, #1e3a8a, #6b21a8, #1e3a8a);
            padding: 2rem;
        }

        .game-container {
            max-width: 64rem;
            margin: 0 auto;
        }

        .header-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title { 
            font-size: 1.875rem; 
            font-weight: bold; 
            color: white;
        }

        .header-title.has-buzzer {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .buzzed-indicator {
            display: inline-block;
            color: #60a5fa;
            font-size: 1rem;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 0.5rem;
            animation: pulseGlow 1s ease-in-out infinite;
        }

        @keyframes pulseGlow {
            0%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px rgba(59, 130, 246, 0.7);
            }
            50% {
                opacity: 0.85;
                text-shadow: 0 0 20px rgba(59, 130, 246, 1);
            }
        }

        .category-display {
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            min-width: 150px;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .score-value {
            color: white;
            font-size: 3rem;
            font-weight: bold;
            line-height: 1;
        }

        .round-selector {
            display: grid;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .round-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .round-title {
            font-size: 0.875rem;
            opacity: 0.8;
            margin-bottom: 0.25rem;
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .question-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 2rem;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:active {
            transform: scale(1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn.completed {
            background: rgba(100, 100, 120, 0.4);
            border-color: rgba(100, 100, 120, 0.6);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .question-btn.completed:hover {
            transform: none;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .clue-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .buttons-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
            height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .buttons-container.player-hidden {
            display: none;
        }

        .timer-bar-container {
            height: 30px;
            background: #7f1d1d;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 0.5rem;
            position: relative;
            box-shadow: 0 5px 8px rgba(0, 0, 0, 0.4), 
                        inset 0 3px 0 rgba(0, 0, 0, 0.4),
                        inset 0 -2px 0 rgba(255, 255, 255, 0.2);
        }

        .timer-bar {
            height: 100%;
            background: #d1d5db;
            transition: width 0.1s linear;
            margin-left: auto;
            border-radius: 0;
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .points-label {
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            margin-bottom: 0.25rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .clue-wrapper {
            display: flex;
            flex-direction: column;
            min-height: 160px;
        }

        .timer-spacer {
            height: 60px;
            margin-bottom: 0rem;
        }

        .clue-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .clue-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 0.5rem;
            padding: 2rem 1rem;
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:hover:not(.revealed):not(.disabled) {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:active:not(.revealed):not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn.revealed {
            background: rgba(59, 130, 246, 0.4);
            border-color: #3b82f6;
            cursor: default;
        }

        .clue-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .answer-box {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            height: 80px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 1.5rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .button-row {
            display: flex;
            gap: 1rem;
        }

        .btn {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-correct {
            background: #22c55e;
            color: white;
        }

        .btn-correct:hover:not(.disabled) {
            background: #16a34a;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-incorrect {
            background: #ef4444;
            color: white;
        }

        .btn-incorrect:hover:not(.disabled) {
            background: #dc2626;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover:not(.disabled) {
            background: #2563eb;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 1.5rem;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:active:not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Connecting Wall Styles */
        .wall-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
            position: relative;
            min-height: 440px;
        }

        .wall-tile {
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(80, 80, 80, 1);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
            cursor: pointer;
            transition: top 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                        left 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        background 0.3s ease,
                        border-color 0.3s ease,
                        transform 0.2s ease,
                        align-items 0.3s ease,
                        padding-top 0.3s ease;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            position: absolute;
        }

        .wall-tile.text-up {
            align-items: flex-start;
            padding-top: 1.5rem;
        }

        .wall-tile:hover:not(.solved):not(.locked):not(.disabled) {
            transform: scale(1.05);
        }

        .wall-tile.selected {
            background: rgba(59, 130, 246, 0.6);
            border-color: rgba(59, 130, 246, 0.9);
            transform: scale(1.05);
        }

        .wall-tile.solved {
            cursor: default;
            pointer-events: none;
        }

        .wall-tile.locked {
            cursor: not-allowed;
        }

        .wall-tile.hidden-text {
            color: transparent;
        }

        .wall-tile.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .wall-tile.group-0 {
            background: rgba(250, 204, 21, 0.55);
            border-color: rgba(250, 204, 21, 0.95);
        }

        .wall-tile.group-1 {
            background: rgba(34, 197, 94, 0.55);
            border-color: rgba(34, 197, 94, 0.95);
        }

        .wall-tile.group-2 {
            background: rgba(59, 130, 246, 0.55);
            border-color: rgba(59, 130, 246, 0.95);
        }

        .wall-tile.group-3 {
            background: rgba(168, 85, 247, 0.55);
            border-color: rgba(168, 85, 247, 0.95);
        }

        .connection-display {
            position: absolute;
            left: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
            color: white;
            font-size: 0.875rem;
            font-weight: bold;
            z-index: 10;
            width: calc(100% - 4px);
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
        }

        .connection-display.fade-in {
            animation: fadeIn 1s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .time-up-modal, .wall-frozen-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .time-up-content, .wall-frozen-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        .time-up-title, .wall-frozen-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .guess-btn {
            width: 45px;
            height: 45px;
            border-radius: 0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .guess-btn.correct {
            background: rgba(34, 197, 94, 0.5);
            border-color: rgba(34, 197, 94, 0.8);
            color: white;
        }

        .guess-btn.incorrect {
            background: rgba(239, 68, 68, 0.5);
            border-color: rgba(239, 68, 68, 0.8);
            color: white;
        }

        .guess-btn:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .guess-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .wall-timer-container {
            margin-top: 1rem;
            transition: opacity 0.5s ease;
        }

        .wall-timer-container.fade-out {
            opacity: 0;
        }

        .wall-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .lives-display {
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
        }

        /* Missing Vowels Styles */
        .vowels-category-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: bold;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .vowels-category-box:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-category-box.disabled {
            cursor: not-allowed;
        }

        .vowels-category-box.disabled:hover {
            transform: none;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-clue-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-clue-text {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.3em;
        }

        .vowels-letter {
            display: inline-block;
            transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .vowels-letter.spread {
            letter-spacing: 0.15em;
        }

        .vowels-letter.vowel {
            opacity: 0;
            transform: scale(0);
        }

        .vowels-letter.vowel.revealed {
            opacity: 1;
            transform: scale(1);
        }

        /* Final Score Screen */
        .final-score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
        }

        .final-score-names {
            color: white;
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }

        .final-score-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem 5rem;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .final-score-value {
            color: white;
            font-size: 6rem;
            font-weight: bold;
            line-height: 1;
        }

        .end-session-btn {
            margin-top: 2rem;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 1rem 3rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.25rem;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn:active:not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Setup Modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .setup-modal-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
            min-width: 400px;
        }

        .setup-modal-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .setup-input {
            width: 100%;
            padding: 1rem;
            font-size: 1.25rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 1.5rem;
            outline: none;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .setup-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .setup-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .setup-btn {
            background: #3b82f6;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .setup-btn:hover {
            background: #2563eb;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .setup-btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .error-message {
            color: #ef4444;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            min-height: 1.5rem;
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <script>
        // Socket.IO connection
        const socket = io(window.location.origin);

        // Game data
        const gameData = {
            round1: [
                { clues: ["Mercury", "Venus", "Earth", "Mars"], connection: "Rocky planets in our solar system", points: [5, 3, 2, 1] },
                { clues: ["Pride", "Envy", "Wrath", "Sloth"], connection: "Seven deadly sins", points: [5, 3, 2, 1] },
                { clues: ["John", "Paul", "George", "Ringo"], connection: "Members of The Beatles", points: [5, 3, 2, 1] },
                { clues: ["Spring", "Summer", "Autumn", "Winter"], connection: "Four seasons", points: [5, 3, 2, 1] },
                { clues: ["Diamond", "Ruby", "Emerald", "Sapphire"], connection: "Precious gemstones", points: [5, 3, 2, 1] },
                { clues: ["North", "South", "East", "West"], connection: "Cardinal directions", points: [5, 3, 2, 1] }
            ],
            round2: [
                { clues: ["1st", "2nd", "3rd", "4th"], answer: "4th", sequence: "Ordinal numbers", points: [5, 3, 2] },
                { clues: ["Bronze", "Silver", "Gold", "Platinum"], answer: "Platinum", sequence: "Record certification levels", points: [5, 3, 2] },
                { clues: ["A", "E", "I", "O"], answer: "O", sequence: "Vowels in alphabetical order", points: [5, 3, 2] },
                { clues: ["Washington", "Adams", "Jefferson", "Madison"], answer: "Madison", sequence: "US Presidents in order", points: [5, 3, 2] },
                { clues: ["90Â°", "180Â°", "270Â°", "360Â°"], answer: "360Â°", sequence: "Quarter rotations", points: [5, 3, 2] },
                { clues: ["New Moon", "First Quarter", "Full Moon", "Last Quarter"], answer: "Last Quarter", sequence: "Phases of the moon", points: [5, 3, 2] }
            ],
            round3: [
                {
                    groups: [
                        { items: ["Bark", "Trunk", "Branch", "Root"], connection: "Parts of a tree" },
                        { items: ["Jupiter", "Saturn", "Uranus", "Neptune"], connection: "Gas giant planets" },
                        { items: ["Red", "Blue", "Green", "Yellow"], connection: "Primary and secondary colors" },
                        { items: ["Apple", "Microsoft", "Amazon", "Google"], connection: "Tech companies" }
                    ]
                }
            ],
            round4: [
                {
                    category: "Types of Cheese",
                    clues: [
                        { withoutVowels: "CHDR", answer: "CHEDDAR" },
                        { withoutVowels: "MZZRLL", answer: "MOZZARELLA" },
                        { withoutVowels: "PRMSN", answer: "PARMESAN" },
                        { withoutVowels: "BR", answer: "BRIE" }
                    ]
                },
                {
                    category: "World Capitals",
                    clues: [
                        { withoutVowels: "PRS", answer: "PARIS" },
                        { withoutVowels: "TKY", answer: "TOKYO" },
                        { withoutVowels: "LDN", answer: "LONDON" },
                        { withoutVowels: "RM", answer: "ROME" }
                    ]
                },
                {
                    category: "Famous Scientists",
                    clues: [
                        { withoutVowels: "NSTN", answer: "EINSTEIN" },
                        { withoutVowels: "NWTN", answer: "NEWTON" },
                        { withoutVowels: "DRWN", answer: "DARWIN" },
                        { withoutVowels: "CR", answer: "CURIE" }
                    ]
                }
            ]
        };

        // Game state
        let myRole = null; // 'host' or 'player1', 'player2', etc.
        let gameCode = null;
        let playerNames = '';
        let allPlayers = []; // Array of all player names
        let showSetupModal = true;
        let setupStep = 'initial'; // 'initial', 'createGame', 'joinGame', 'enterName'
        let score = 0;
        let view = 'rounds';
        let currentRound = null;
        let currentQuestion = null;
        let cluesRevealed = 0;
        let answerRevealed = false;
        let completedQuestions = [];
        let sequentialQuestionIndex = 0; // Track which question we're on in sequential play
        let timerStartTime = null;
        let timerInterval = null;
        let timerDuration = 60000;
        let timerElapsedWhenStopped = 0;
        let timerStopped = false;
        let timerStoppedOnClue = null;
        let timerRemainingWhenStopped = null;
        let showCluesTimeUpModal = false;

        // Round 3 (Connecting Wall) state
        let wallTiles = [];
        let selectedTiles = [];
        let solvedGroups = [];
        let wallLives = 3;
        let wallPhase = 'setup'; // 'setup', 'solving', 'guessing', 'complete'
        let connectionGuesses = {};
        let wallTimerStarted = false;
        let showWallTimeUpModal = false;
        let showWallFrozenModal = false;
        let wallAnimations = new Map(); // Track tile positions for animations

        // Round 4 (Missing Vowels) state
        let vowelsCurrentCategory = 0;
        let vowelsCurrentClue = 0;
        let vowelsCategoryRevealed = false;
        let vowelsCategoryAnimating = false;
        let vowelsClueRevealed = false;
        let vowelsAnswerRevealed = false;
        let vowelsShowTimeUpModal = false;
        
        // Buzzer state
        let buzzedInPlayer = null;

        // Category display
        let currentCategoryName = '';

        // Socket event listeners
        socket.on('gameCreated', ({ gameCode: code, role }) => {
            gameCode = code;
            myRole = role;
            showSetupModal = false;
            render();
        });

        socket.on('gameJoined', ({ gameCode: code, role, playerName }) => {
            gameCode = code;
            myRole = role;
            playerNames = playerName;
            showSetupModal = false;
            render();
        });

        socket.on('gameCodeExists', () => {
            alert('Game code already exists. Please choose another.');
        });

        socket.on('gameNotFound', () => {
            alert('Game not found. Please check the code.');
        });

        socket.on('playersUpdated', ({ players }) => {
            allPlayers = players;
            updatePlayerNamesDisplay();
            render();
        });

        socket.on('syncGameState', (gameState) => {
            // Store the current timer state
            const wasTimerRunning = timerInterval !== null && !timerStopped;
            
            // Update all state from host
            score = gameState.score;
            view = gameState.view;
            currentRound = gameState.currentRound;
            currentQuestion = gameState.currentQuestion;
            cluesRevealed = gameState.cluesRevealed;
            answerRevealed = gameState.answerRevealed;
            completedQuestions = gameState.completedQuestions;
            timerStopped = gameState.timerStopped;
            timerElapsedWhenStopped = gameState.timerElapsedWhenStopped;
            timerStartTime = gameState.timerStartTime;
            timerDuration = gameState.timerDuration;
            timerStoppedOnClue = gameState.timerStoppedOnClue;
            timerRemainingWhenStopped = gameState.timerRemainingWhenStopped;
            buzzedInPlayer = gameState.buzzedInPlayer;
            showCluesTimeUpModal = gameState.showCluesTimeUpModal;
            
            // Wall state
            wallTiles = gameState.wallTiles;
            selectedTiles = gameState.selectedTiles;
            solvedGroups = gameState.solvedGroups;
            wallLives = gameState.wallLives;
            wallPhase = gameState.wallPhase;
            connectionGuesses = gameState.connectionGuesses;
            wallTimerStarted = gameState.wallTimerStarted;
            showTimeUpModal = gameState.showTimeUpModal;
            showWallFrozenModal = gameState.showWallFrozenModal;
            
            // Vowels state
            vowelsCurrentCategory = gameState.vowelsCurrentCategory;
            vowelsCurrentClue = gameState.vowelsCurrentClue;
            vowelsCategoryRevealed = gameState.vowelsCategoryRevealed;
            vowelsCategoryAnimating = gameState.vowelsCategoryAnimating;
            vowelsClueRevealed = gameState.vowelsClueRevealed;
            vowelsAnswerRevealed = gameState.vowelsAnswerRevealed;
            vowelsShowTimeUpModal = gameState.vowelsShowTimeUpModal;
            currentCategoryName = gameState.currentCategoryName || '';
            
            // Handle timer state
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // If timer is stopped and we have a frozen time, show it
            if (timerStopped && timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            } else if (!timerStopped && timerStartTime) {
                // Timer is running
                const now = Date.now();
                const elapsed = timerElapsedWhenStopped + (now - timerStartTime);
                const remaining = Math.max(0, timerDuration - elapsed);
                
                updateTimerDisplay(remaining);
                
                if (remaining > 0) {
                    timerInterval = setInterval(updateTimer, 100);
                }
            }
            
            render();
        });

        socket.on('playerBuzzed', ({ playerName }) => {
            buzzedInPlayer = playerName;
            if (isHost()) {
                // Stop timer when player buzzes
                stopTimer();
                render();
            } else {
                // On player side, just update the UI
                render();
            }
        });

        socket.on('gameAction', (action) => {
            // Players only - host ignores its own broadcasts
            if (isHost()) return;
            
            // Handle dismissTimeUpModal specifically
            if (action.type === 'dismissTimeUpModal') {
                showCluesTimeUpModal = false;
                render();
            } else if (typeof window[action.type] === 'function') {
                // Execute other actions
                window[action.type].apply(null, action.params || []);
            }
        });

        socket.on('wallAction', ({ action }) => {
            // Handle wall actions from players (only host processes these)
            if (myRole === 'host') {
                console.log('DEBUG HOST received wallAction:', action);
                if (action.type === 'toggleTile') {
                    toggleTile(action.tileId);
                } else if (action.type === 'checkGroup') {
                    checkGroup();
                }
            }
        });

        socket.on('hostDisconnected', () => {
            alert('Host disconnected. Game session ended.');
            location.reload();
        });

        // Helper functions
        function isHost() {
            return myRole === 'host';
        }

        function isPlayer() {
            return myRole && myRole.startsWith('player');
        }

        function syncGameState() {
            if (!isHost()) return;
            
            const state = {
                // Basic game state
                score,
                view,
                currentRound,
                currentQuestion,
                currentCategoryName: currentCategoryName || '',
                
                // Clues state
                cluesRevealed,
                answerRevealed,
                completedQuestions,
                buzzedInPlayer,
                
                // Timer state
                timerStopped,
                timerElapsedWhenStopped,
                timerRemainingWhenStopped,
                timerStartTime,
                timerDuration,
                timerStoppedOnClue,
                
                // Modal states
                showCluesTimeUpModal,
                showTimeUpModal,
                showWallFrozenModal,
                vowelsShowTimeUpModal,
                
                // Wall state
                wallTiles,
                selectedTiles,
                solvedGroups,
                wallLives,
                wallPhase,
                connectionGuesses,
                wallTimerStarted,
                
                // Vowels state
                vowelsCurrentCategory,
                vowelsCurrentClue,
                vowelsCategoryRevealed,
                vowelsCategoryAnimating,
                vowelsClueRevealed,
                vowelsAnswerRevealed
            };
            
            socket.emit('syncState', state);
        }
        
        function broadcastAction(type, params = []) {
            if (!isHost()) return;
            socket.emit('hostAction', { type, params });
        }
        
        function updatePlayerNamesDisplay() {
            if (isHost()) {
                if (allPlayers.length === 0) {
                    playerNames = "Waiting for players...";
                } else if (allPlayers.length === 1) {
                    playerNames = allPlayers[0].name;
                } else if (allPlayers.length === 2) {
                    playerNames = allPlayers[0].name + " & " + allPlayers[1].name;
                } else {
                    const lastPlayer = allPlayers[allPlayers.length - 1].name;
                    const otherPlayers = allPlayers.slice(0, -1).map(p => p.name).join(", ");
                    playerNames = otherPlayers + ", & " + lastPlayer;
                }
            }
        }

        // Timer functions
        function startTimer() {
            if (timerStartTime === null) {
                // Reset all modal states when starting a new timer
                resetAllModals();
                
                // Reset timer state
                timerStartTime = Date.now();
                timerStopped = false;
                timerElapsedWhenStopped = 0;
                timerRemainingWhenStopped = null;  // Clear any frozen time
                
                // Start the timer
                timerInterval = setInterval(updateTimer, 100);
                
                // Sync the state if host
                if (isHost()) {
                    syncGameState();
                }
            }
        }
        
        function resetAllModals() {
            showTimeUpModal = false;
            showCluesTimeUpModal = false;
            vowelsShowTimeUpModal = false;
        }

        function updateTimer() {
            // Don't update if timer is stopped
            if (timerStopped) return;
            
            if (!timerStartTime) return;

            const now = Date.now();
            const elapsed = timerElapsedWhenStopped + (now - timerStartTime);
            const remaining = Math.max(0, timerDuration - elapsed);

            updateTimerDisplay(remaining);

            if (remaining <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;

                if (isHost()) {
                    handleTimerExpiration();
                }
            }
        }
        
        function updateTimerDisplay(remaining) {
            const percentage = (remaining / timerDuration) * 100;
            const seconds = Math.ceil(remaining / 1000);
            
            // Update all timer bars and texts (there might be multiple)
            for (let i = 0; i < 4; i++) {
                const timerBar = document.getElementById(`timerBar-${i}`);
                const timerText = document.getElementById(`timerText-${i}`);
                if (timerBar) timerBar.style.width = percentage + '%';
                if (timerText) timerText.textContent = seconds + 's';
            }
            
            // Also update the non-indexed ones for other rounds
            const mainTimerBar = document.getElementById('timerBar');
            const mainTimerText = document.getElementById('timerText');
            if (mainTimerBar) mainTimerBar.style.width = percentage + '%';
            if (mainTimerText) mainTimerText.textContent = seconds + 's';
        }

        function handleTimerExpiration() {
            if (!isHost()) return;
            
            // Set the appropriate modal flag based on current view
            if (view === 'clues') {
                showCluesTimeUpModal = true;
                timerStopped = true;
                timerRemainingWhenStopped = 0;  // Freeze at 0 when time expires
                
                // Lock the timer position when time expires
                if (timerStoppedOnClue === null) {
                    timerStoppedOnClue = Math.max(0, cluesRevealed - 1);
                }
            } else if (view === 'wall') {
                showWallFrozenModal = true;
                timerStopped = true;
            } else if (view === 'vowels') {
                vowelsShowTimeUpModal = true;
                timerStopped = true;
            }
            
            syncGameState();
            render();
        }

        function dismissTimeUpModal() {
            if (!isHost()) return;
            
            // Clear the modal flag
            showCluesTimeUpModal = false;
            
            // Make sure timer is fully stopped
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerStopped = true;
            
            // Sync state to all clients FIRST
            syncGameState();
            
            // Then broadcast the specific action
            broadcastAction('dismissTimeUpModal');
            
            // Finally render for host
            render();
        }
        
        function resetTimer() {
            // Clear any running timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Reset timer state
            timerStartTime = null;
            timerStopped = false;
            timerElapsedWhenStopped = 0;
            timerStoppedOnClue = null;
            timerRemainingWhenStopped = null;
            
            // Reset modal states
            showTimeUpModal = false;
            showCluesTimeUpModal = false;
            vowelsShowTimeUpModal = false;
            
            // If host, sync the state
            if (isHost()) {
                syncGameState();
            }
        }
        
        function stopTimer() {
            // First, capture the remaining time BEFORE clearing anything
            if (timerStartTime && timerRemainingWhenStopped === null) {
                const elapsed = timerElapsedWhenStopped + (Date.now() - timerStartTime);
                timerRemainingWhenStopped = Math.max(0, timerDuration - elapsed);
            }
            
            // Clear the interval
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Update elapsed time
            if (timerStartTime) {
                timerElapsedWhenStopped += Date.now() - timerStartTime;
                timerStartTime = null;
            }
            
            timerStopped = true;
            
            // Record which clue the timer stopped on
            if (timerStoppedOnClue === null) {
                timerStoppedOnClue = Math.max(0, cluesRevealed - 1);
            }
            
            // Update the display with the frozen time
            if (timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            }
            
            // Sync the state if host
            if (isHost()) {
                syncGameState();
            }
        }

        // Keyboard event listener for spacebar (players only)
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && isPlayer()) {
                if ((view === 'clues' && cluesRevealed > 0 && !timerStopped) ||
                    (view === 'vowels' && vowelsCategoryRevealed && vowelsClueRevealed && !timerStopped)) {
                    event.preventDefault();
                    socket.emit('buzzIn');
                }
            }
        });

        // Game functions with role restrictions
        function selectRound(roundIndex) {
            if (!isHost()) return;
            
            currentRound = roundIndex;
            
            // Reset all modals when switching rounds
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            
            if (roundIndex === 2) {
                initializeWall();
                view = 'wall';
                currentCategoryName = "Connecting Wall";
            } else if (roundIndex === 3) {
                initializeVowels();
                view = 'vowels';
                currentCategoryName = "Missing Vowels";
            } else {
                // For rounds 0 (Connections) and 1 (Sequences)
                view = 'questions';
                // Reset question state
                currentQuestion = null;
                cluesRevealed = 0;
                answerRevealed = false;
                // Set sequential index based on completed questions
                const questionsInRound = roundIndex === 0 ? gameData.round1.length : gameData.round2.length;
                sequentialQuestionIndex = 0;
                for (let i = 0; i < questionsInRound; i++) {
                    const questionKey = `r${roundIndex}q${i}`;
                    if (completedQuestions.includes(questionKey)) {
                        sequentialQuestionIndex = i + 1;
                    } else {
                        break;
                    }
                }
            }
            
            broadcastAction('selectRound', [roundIndex]);
            syncGameState();
            render();
        }

        function selectQuestion(questionIndex) {
            if (!isHost()) return;
            
            const questionKey = `r${currentRound}q${questionIndex}`;
            if (completedQuestions.includes(questionKey)) return;
            
            // Reset all relevant states
            currentQuestion = questionIndex;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerElapsedWhenStopped = 0;
            timerStartTime = null;
            timerStoppedOnClue = null;
            timerElapsedWhenStopped = null;
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            buzzedInPlayer = null;
            
            // Reset the timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Set category name and timer duration
            switch (currentRound) {
                case 0:
                    currentCategoryName = "Connections";
                    break;
                case 1:
                    currentCategoryName = "Sequences";
                    break;
            }
            
            // Set the view to 'clues' and timer duration
            view = 'clues';
            timerDuration = 60000; // 1 minute for each question
            
            // Sync the state with players
            syncGameState();
            render();
        }

        function revealClue(index) {
            if (!isHost()) return;
            
            const isSequence = currentRound === 1;
            
            if (index === cluesRevealed) {
                if (isSequence && index === 3 && !timerStopped) {
                    return;
                }
                
                cluesRevealed++;
                
                // Only start timer if not already stopped (by buzzer or timeout)
                if (!timerStopped && cluesRevealed < 4) {
                    startTimer();
                }
                
                broadcastAction('revealClue', [index]);
                syncGameState();
                render();
            }
        }

        function markCorrect() {
            if (!isHost()) return;
            
            const isSequence = currentRound === 1;
            const question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            const pointsValues = question.points;
            const pointsEarned = pointsValues[timerStoppedOnClue];
            score += pointsEarned;
            answerRevealed = true;
            buzzedInPlayer = null;
            
            broadcastAction('markCorrect');
            syncGameState();
            render();
        }

        function markIncorrect() {
            if (!isHost()) return;
            
            answerRevealed = true;
            buzzedInPlayer = null;
            
            broadcastAction('markIncorrect');
            syncGameState();
            render();
        }

        // Player-side function to handle the broadcast
        function revealRemainingCluesFromPlayerSide() {
            // This will be called via gameAction broadcast
            // The state sync from host will handle everything
            render();
        }

        function completeQuestion() {
            if (!isHost()) return;
            
            const questionKey = `r${currentRound}q${currentQuestion}`;
            if (!completedQuestions.includes(questionKey)) {
                completedQuestions.push(questionKey);
            }
            
            sequentialQuestionIndex++;
            
            // Reset all modals when completing a question
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            
            // Broadcast the completion
            broadcastAction('completeQuestion');
            
            // Auto-advance logic
            const questionsInCurrentRound = currentRound === 0 ? gameData.round1.length : gameData.round2.length;
            
            if (currentQuestion < questionsInCurrentRound - 1) {
                // Move to next question in same round
                selectQuestion(currentQuestion + 1);
            } else {
                // Finished round, move to next round
                if (currentRound === 0) {
                    // Move from Round 1 to Round 2
                    selectRound(1);
                } else if (currentRound === 1) {
                    // Move from Round 2 to Round 3 (Wall)
                    selectRound(2);
                } else {
                    // Shouldn't happen with current flow, but fallback
                    backToRounds();
                }
            }
        }

        function backToRounds() {
            if (!isHost()) return;
            
            view = 'rounds';
            currentRound = null;
            currentQuestion = null;
            resetTimer();
            
            broadcastAction('backToRounds');
            syncGameState();
            render();
        }

        function backToQuestions() {
            if (!isHost()) return;
            
            view = 'questions';
            currentQuestion = null;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerStoppedOnClue = null;
            showCluesTimeUpModal = false;
            buzzedInPlayer = null;
            resetTimer();
            
            broadcastAction('backToQuestions');
            syncGameState();
            render();
        }

        function endGame() {
            if (!isHost()) return;
            
            view = 'finalScore';
            
            broadcastAction('endGame');
            syncGameState();
            render();
        }

        function endSession() {
            if (!isHost()) return;
            
            location.reload();
        }

        // Round 4 (Missing Vowels) functions
        function initializeVowels() {
            vowelsCurrentCategory = 0;
            vowelsCurrentClue = 0;
            vowelsCategoryRevealed = false;
            vowelsCategoryAnimating = false;
            vowelsClueRevealed = false;
            vowelsAnswerRevealed = false;
            vowelsShowTimeUpModal = false;
            resetTimer();
            timerDuration = 120000;
        }

        function revealCategoryAndStartTimer() {
            if (!isHost()) return;
            
            if (!vowelsCategoryRevealed) {
                vowelsCategoryRevealed = true;
                vowelsCategoryAnimating = true;
                
                // Don't change currentCategoryName - keep it as "Missing Vowels"
                
                syncGameState();
                render();
                
                setTimeout(() => {
                    vowelsCategoryAnimating = false;
                    vowelsClueRevealed = true;
                    // Only start timer if it hasn't been started yet
                    if (timerStartTime === null) {
                        startTimer();
                    }
                    
                    broadcastAction('revealCategoryAndStartTimer');
                    syncGameState();
                    render();
                }, 3000);
            }
        }

        function markVowelsCorrect() {
            if (!isHost()) return;
            
            score += 1;
            vowelsAnswerRevealed = true;
            
            // Restart timer from where it stopped
            if (timerStopped) {
                timerStopped = false;
                timerStartTime = Date.now();
                // timerElapsedWhenStopped already has the right value
                if (!timerInterval) {
                    timerInterval = setInterval(updateTimer, 100);
                }
            }
            
            setTimeout(() => {
                const clueElement = document.querySelector('.vowels-clue-text');
                if (clueElement) {
                    const letters = clueElement.querySelectorAll('.vowels-letter');
                    letters.forEach(letter => {
                        if (letter.classList.contains('vowel')) {
                            letter.classList.add('revealed');
                        }
                    });
                }
            }, 50);
            
            broadcastAction('markVowelsCorrect');
            syncGameState();
            render();
        }

        function markVowelsIncorrect() {
            if (!isHost()) return;
            
            vowelsAnswerRevealed = true;
            
            // Restart timer from where it stopped
            if (timerStopped) {
                timerStopped = false;
                timerStartTime = Date.now();
                // timerElapsedWhenStopped already has the right value
                if (!timerInterval) {
                    timerInterval = setInterval(updateTimer, 100);
                }
            }
            
            setTimeout(() => {
                const clueElement = document.querySelector('.vowels-clue-text');
                if (clueElement) {
                    const letters = clueElement.querySelectorAll('.vowels-letter');
                    letters.forEach(letter => {
                        if (letter.classList.contains('vowel')) {
                            letter.classList.add('revealed');
                        }
                    });
                }
            }, 50);
            
            broadcastAction('markVowelsIncorrect');
            syncGameState();
            render();
        }

        function nextVowelsClue() {
            if (!isHost()) return;
            
            const category = gameData.round4[vowelsCurrentCategory];
            
            if (vowelsCurrentClue < category.clues.length - 1) {
                vowelsCurrentClue++;
                vowelsClueRevealed = true;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;  // Clear buzzer for next clue
                
                // Timer continues running automatically after markCorrect/Incorrect resumed it
                
                broadcastAction('nextVowelsClue');
                syncGameState();
                render();
            } else {
                // End of category
                stopTimer();
                vowelsClueRevealed = false;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;
                
                syncGameState();
                render();
            }
        }

        function nextVowelsCategory() {
            if (!isHost()) return;
            
            const category = gameData.round4[vowelsCurrentCategory];
            if (vowelsCurrentClue !== category.clues.length - 1 || !vowelsAnswerRevealed) {
                return;
            }
            
            if (vowelsCurrentCategory < gameData.round4.length - 1) {
                vowelsCurrentCategory++;
                vowelsCurrentClue = 0;
                vowelsCategoryRevealed = true;
                vowelsCategoryAnimating = true;
                vowelsClueRevealed = false;
                vowelsAnswerRevealed = false;
                
                syncGameState();
                render();
                
                setTimeout(() => {
                    vowelsCategoryAnimating = false;
                    vowelsClueRevealed = true;
                    
                    // Don't reset the timer - just continue from where it was
                    if (timerInterval === null && timerStartTime !== null) {
                        // Resume the timer if it was running
                        timerInterval = setInterval(updateTimer, 100);
                    }
                    
                    broadcastAction('nextVowelsCategory');
                    syncGameState();
                    render();
                }, 3000);
            }
        }

        function revealVowelsAnswerFromModal() {
            if (!isHost()) return;
            
            vowelsShowTimeUpModal = false;
            
            // When time runs out, immediately move to end game state
            // Don't play through remaining clues
            vowelsClueRevealed = false;
            vowelsAnswerRevealed = true;
            stopTimer();
            
            broadcastAction('revealVowelsAnswerFromModal');
            syncGameState();
            render();
        }

        function isVowel(char) {
            return 'AEIOU'.includes(char.toUpperCase());
        }

        function createAnimatedClueText(withoutVowels, fullAnswer, revealed) {
            const answerChars = fullAnswer.split('');
            
            let html = '<div class="vowels-clue-text">';
            
            for (let i = 0; i < answerChars.length; i++) {
                const char = answerChars[i];
                
                if (char === ' ') {
                    html += '<span class="vowels-letter" style="width: 1em;"> </span>';
                } else if (isVowel(char)) {
                    const vowelClass = revealed ? 'vowels-letter vowel revealed' : 'vowels-letter vowel';
                    html += `<span class="${vowelClass}">${char}</span>`;
                } else {
                    html += `<span class="vowels-letter">${char}</span>`;
                }
            }
            
            html += '</div>';
            return html;
        }

        // Round 3 (Connecting Wall) functions
        function initializeWall() {
            const wallData = gameData.round3[0];
            
            // Create tiles from groups
            let allTiles = [];
            wallData.groups.forEach((group, groupIndex) => {
                group.items.forEach(item => {
                    allTiles.push({
                        id: Math.random().toString(36).substr(2, 9), // Unique ID for tracking
                        text: item,
                        groupIndex: groupIndex,
                        solved: false,
                        position: null
                    });
                });
            });
            
            // Shuffle and assign positions
            wallTiles = shuffleArray(allTiles);
            wallTiles.forEach((tile, index) => {
                tile.position = index;
            });
            
            // Reset state
            selectedTiles = [];
            solvedGroups = [];
            wallLives = 3;
            wallPhase = 'setup';
            connectionGuesses = {};
            wallTimerStarted = false;
            showWallTimeUpModal = false;
            showWallFrozenModal = false;
            wallAnimations.clear();
            
            // Setup timer
            resetTimer();
            timerDuration = 180000; // 3 minutes
        }

        function startWallTimer() {
            if (!isHost() || wallTimerStarted) return;
            
            wallTimerStarted = true;
            wallPhase = 'solving';
            startTimer();
            
            broadcastAction('startWallTimer');
            syncGameState();
            render();
        }

        function handleWallTimerExpired() {
            if (!isHost()) return;
            
            showWallTimeUpModal = true;
            timerStopped = true;
            
            syncGameState();
            render();
        }

        function toggleTile(tileId) {
            console.log('DEBUG toggleTile called - tileId:', tileId, 'isPlayer:', isPlayer(), 'wallPhase:', wallPhase);

            // Players send request to host
            if (isPlayer() && wallPhase === 'solving') {
                socket.emit('wallAction', { action: { type: 'toggleTile', tileId } });
                return;
            }
            
            // Host processes the toggle
            if (!isHost() || wallPhase !== 'solving' || timerStopped) return;
            
            const tile = wallTiles.find(t => t.id === tileId);
            if (!tile || tile.solved) return;
            
            const selectedIndex = selectedTiles.findIndex(id => id === tileId);
            
            if (selectedIndex > -1) {
                // Deselect
                selectedTiles.splice(selectedIndex, 1);
            } else if (selectedTiles.length < 4) {
                // Select
                selectedTiles.push(tileId);
                
                // Auto-check when 4 selected
                if (selectedTiles.length === 4) {
                    setTimeout(checkGroup, 300);
                }
            }
            
            syncGameState();
            render();
        }

        function checkGroup() {
            if (!isHost() || selectedTiles.length !== 4) return;
            
            // Get the group indices of selected tiles
            const selectedGroups = selectedTiles.map(id => {
                const tile = wallTiles.find(t => t.id === id);
                return tile.groupIndex;
            });
            
            // Check if all same group
            const isCorrect = selectedGroups.every(g => g === selectedGroups[0]);
            
            if (isCorrect) {
                handleCorrectGroup();
            } else {
                handleIncorrectGroup();
            }
        }

        function handleCorrectGroup() {
            const groupIndex = wallTiles.find(t => t.id === selectedTiles[0]).groupIndex;
            const wallData = gameData.round3[0];
            
            // Mark tiles as solved
            selectedTiles.forEach(tileId => {
                const tile = wallTiles.find(t => t.id === tileId);
                tile.solved = true;
                tile.solvedGroupIndex = solvedGroups.length;
            });
            
            // Add to solved groups
            solvedGroups.push({
                tiles: selectedTiles.slice(),
                groupIndex: groupIndex,
                connection: wallData.groups[groupIndex].connection
            });
            
            // Clear selection
            selectedTiles = [];
            score += 1;
            
            // Rearrange tiles with animation
            rearrangeTiles();
            
            // Check if wall complete
            if (solvedGroups.length === 3) {
                // Auto-solve last group
                setTimeout(autoSolveLastGroup, 1000);
            }
            
            syncGameState();
            render();
        }

        function handleIncorrectGroup() {
            const remainingGroups = 4 - solvedGroups.length;
            
            if (remainingGroups === 2) {
                wallLives--;
                
                if (wallLives === 0) {
                    // Wall frozen
                    showWallFrozenModal = true;
                    stopTimer();
                }
            }
            
            selectedTiles = [];
            syncGameState();
            render();
        }

        function rearrangeTiles() {
            // Store old positions for animation
            wallTiles.forEach(tile => {
                const element = document.querySelector(`[data-tile-id="${tile.id}"]`);
                if (element) {
                    const rect = element.getBoundingClientRect();
                    wallAnimations.set(tile.id, { oldTop: rect.top, oldLeft: rect.left });
                }
            });
            
            // Calculate new positions
            let newPosition = 0;
            
            // First, position solved groups
            solvedGroups.forEach((group, groupIdx) => {
                group.tiles.forEach(tileId => {
                    const tile = wallTiles.find(t => t.id === tileId);
                    tile.position = newPosition++;
                });
            });
            
            // Then position unsolved tiles
            wallTiles.forEach(tile => {
                if (!tile.solved) {
                    tile.position = newPosition++;
                }
            });
        }

        function autoSolveLastGroup() {
            const wallData = gameData.round3[0];
            const unsolvedTiles = wallTiles.filter(t => !t.solved);
            
            if (unsolvedTiles.length === 4) {
                const groupIndex = unsolvedTiles[0].groupIndex;
                
                unsolvedTiles.forEach(tile => {
                    tile.solved = true;
                    tile.solvedGroupIndex = solvedGroups.length;
                });
                
                solvedGroups.push({
                    tiles: unsolvedTiles.map(t => t.id),
                    groupIndex: groupIndex,
                    connection: wallData.groups[groupIndex].connection
                });
                
                score += 1;
                rearrangeTiles();
            }
            
            // Move to guessing phase
            setTimeout(() => {
                wallPhase = 'guessing';
                stopTimer();
                syncGameState();
                render();
            }, 1000);
        }
        
        function renderWall() {
            console.log('DEBUG renderWall - wallPhase:', wallPhase, 'wallTimerStarted:', wallTimerStarted, 'isHost():', isHost());

            const remainingGroups = 4 - solvedGroups.length;
            const showLives = remainingGroups === 2 && wallPhase === 'solving' && wallTimerStarted;
            
            let html = '<div class="wall-header">';
            const hideButton = wallTimerStarted ? ' style="visibility: hidden;"' : '';
            
            // Back button (hidden during solving)
            if (wallPhase === 'setup') {
                html += `<button class="back-btn ${!isHost() ? 'disabled' : ''}" onclick="backToRounds()">← Back to Rounds</button>`;
            } else {
                html += '<div style="width: 150px;"></div>';
            }
            
            // Lives display
            if (showLives) {
                html += `<div class="lives-display">Lives: ${'❤️'.repeat(wallLives)}${'🖤'.repeat(3 - wallLives)}</div>`;
            }
            
            html += '</div>';
            
            // Wall grid
            html += '<div class="wall-grid">';
            
            // Render tiles
            wallTiles.forEach(tile => {
                const row = Math.floor(tile.position / 4);
                const col = tile.position % 4;
                const top = row * 112; // 100px tile + 12px gap
                const left = `${col * 25}%`;
                
                let classes = 'wall-tile';
                if (tile.solved) {
                    classes += ` solved group-${tile.solvedGroupIndex}`;
                }
                if (selectedTiles.includes(tile.id)) {
                    classes += ' selected';
                }
                if (wallPhase === 'setup') {
                    classes += ' hidden-text';
                }
                
                const canClick = (isPlayer() && wallPhase === 'solving' && wallTimerStarted && !tile.solved);
                if (!canClick && !tile.solved && wallPhase === 'solving') {
                    classes += ' disabled';
                }
                const onclick = canClick ? `onclick="toggleTile('${tile.id}')"` : '';

                html += `<button class="${classes}" ${onclick} style="top: ${top}px; left: ${left}; width: calc(25% - 9px);" data-tile-id="${tile.id}">${tile.text}</button>`;
            });
            
            // Connection displays for guessing phase
            if (wallPhase === 'guessing') {
                solvedGroups.forEach((group, idx) => {
                    const row = idx;
                    const top = row * 112 + 50;
                    
                    if (connectionGuesses[idx]) {
                        html += `<div class="connection-display fade-in" style="top: ${top}px; opacity: 1;">${group.connection}</div>`;
                    } else if (isHost()) {
                        const buttonsTop = row * 112 + 27;
                        html += `<div style="position: absolute; right: -60px; top: ${buttonsTop}px;">`;
                        html += `<button class="guess-btn correct" onclick="guessConnection(${idx}, true)">✓</button>`;
                        html += `<button class="guess-btn incorrect" onclick="guessConnection(${idx}, false)">✗</button>`;
                        html += '</div>';
                    }
                });
            }
            
            html += '</div>';
            
            // Timer section
            if (wallPhase === 'setup' && isHost()) {
                html += '<div style="text-align: center; margin-top: 2rem;">';
                html += '<button class="btn btn-primary" onclick="startWallTimer()">Start Timer</button>';
                html += '</div>';
            } else if (wallPhase === 'solving') {
                html += '<div class="timer-bar-container" style="margin-top: 1rem;">';
                html += '<div id="timerBar" class="timer-bar"></div>';
                html += '<div id="timerText" class="timer-text">180s</div>';
                html += '</div>';
            }
            
            // Continue button for guessing complete
            if (wallPhase === 'guessing' && Object.keys(connectionGuesses).length === solvedGroups.length && isHost()) {
                html += '<div style="text-align: center; margin-top: 2rem;">';
                html += '<button class="btn btn-primary" onclick="selectRound(3)">Continue to Missing Vowels</button>';
                html += '</div>';
            }
            
            // Modals
            if (showWallTimeUpModal) {
                html += renderWallTimeUpModal();
            }
            if (showWallFrozenModal) {
                html += renderWallFrozenModal();
            }
            
            return html;
        }

        function guessConnection(groupIndex, isCorrect) {
            if (!isHost()) return;
            
            connectionGuesses[groupIndex] = isCorrect;
            if (isCorrect) score += 1;
            
            // Check for bonus
            if (Object.keys(connectionGuesses).length === 4) {
                const allCorrect = Object.values(connectionGuesses).every(v => v);
                const allFound = solvedGroups.every(g => !g.autoSolved);
                
                if (allCorrect && allFound) {
                    score += 2; // Bonus points
                }
            }
            
            syncGameState();
            render();
        }

        function renderWallTimeUpModal() {
            let html = '<div class="time-up-modal">';
            html += '<div class="time-up-content">';
            html += '<div class="time-up-title">Time is Up</div>';
            if (isHost()) {
                html += '<button class="btn btn-primary" onclick="resolveWallTimeout()">Resolve Wall</button>';
            }
            html += '</div></div>';
            return html;
        }

        function renderWallFrozenModal() {
            let html = '<div class="wall-frozen-modal">';
            html += '<div class="wall-frozen-content">';
            html += '<div class="wall-frozen-title">The Wall has Frozen!</div>';
            if (isHost()) {
                html += '<button class="btn btn-primary" onclick="resolveWallFrozen()">Resolve Wall</button>';
            }
            html += '</div></div>';
            return html;
        }

        function resolveWallTimeout() {
            if (!isHost()) return;
            showWallTimeUpModal = false;
            autoSolveRemaining();
        }

        function resolveWallFrozen() {
            if (!isHost()) return;
            showWallFrozenModal = false;
            autoSolveRemaining();
        }

        function autoSolveRemaining() {
            // Auto-solve all remaining groups
            const wallData = gameData.round3[0];
            
            for (let g = 0; g < 4; g++) {
                if (!solvedGroups.some(sg => sg.groupIndex === g)) {
                    const tiles = wallTiles.filter(t => t.groupIndex === g && !t.solved);
                    tiles.forEach(t => {
                        t.solved = true;
                        t.solvedGroupIndex = solvedGroups.length;
                    });
                    
                    solvedGroups.push({
                        tiles: tiles.map(t => t.id),
                        groupIndex: g,
                        connection: wallData.groups[g].connection,
                        autoSolved: true
                    });
                }
            }
            
            rearrangeTiles();
            wallPhase = 'guessing';
            syncGameState();
            render();
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Render functions
        function renderSetupModal() {
            if (!showSetupModal) return '';
            
            if (setupStep === 'initial') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Only Connect</div>
                            <button class="setup-btn" onclick="showHostPassword()">New Game (Host)</button>
                            <button class="setup-btn" onclick="showJoinGame()">Join Game (Player)</button>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'hostPassword') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Host Verification</div>
                            <p style="color: white; margin-bottom: 1rem; font-size: 0.875rem;">Enter production password to continue</p>
                            <input type="password" 
                                   id="passwordInput" 
                                   class="setup-input" 
                                   placeholder="Password" 
                                   onkeypress="if(event.key === 'Enter') verifyHostPassword()">
                            <button class="setup-btn" onclick="verifyHostPassword()">Verify</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'createGame') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Create Game</div>
                            <input type="text" 
                                   id="gameCodeInput" 
                                   class="setup-input" 
                                   placeholder="Enter game code (e.g., Veto2)" 
                                   onkeypress="if(event.key === 'Enter') createGame()">
                            <button class="setup-btn" onclick="createGame()">Create Game</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'joinGame') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Join Game</div>
                            <input type="text" 
                                   id="joinCodeInput" 
                                   class="setup-input" 
                                   placeholder="Enter game code" 
                                   onkeypress="if(event.key === 'Enter') proceedToName()">
                            <button class="setup-btn" onclick="proceedToName()">Next</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'enterName') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Enter Your Name</div>
                            <input type="text" 
                                   id="playerNameInput" 
                                   class="setup-input" 
                                   placeholder="Your name" 
                                   onkeypress="if(event.key === 'Enter') joinGame()">
                            <button class="setup-btn" onclick="joinGame()">Join Game</button>
                            <button class="setup-btn" onclick="setupStep = 'joinGame'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            }
        }

        function showHostPassword() {
            setupStep = 'hostPassword';
            render();
            setTimeout(() => {
                const input = document.getElementById('passwordInput');
                if (input) input.focus();
            }, 100);
        }

        function verifyHostPassword() {
            const input = document.getElementById('passwordInput');
            const password = input ? input.value : '';
            const correctPassword = 'Haych22'; // Change this to your desired password
            
            if (password === correctPassword) {
                showCreateGame();
            } else {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Incorrect password. Access denied.';
                setTimeout(() => {
                    setupStep = 'initial';
                    render();
                }, 2000);
            }
        }

        function showCreateGame() {
            setupStep = 'createGame';
            render();
            setTimeout(() => {
                const input = document.getElementById('gameCodeInput');
                if (input) input.focus();
            }, 100);
        }

        function showJoinGame() {
            setupStep = 'joinGame';
            render();
            setTimeout(() => {
                const input = document.getElementById('joinCodeInput');
                if (input) input.focus();
            }, 100);
        }

        function createGame() {
            const input = document.getElementById('gameCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            socket.emit('createGame', code);
        }

        function proceedToName() {
            const input = document.getElementById('joinCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            gameCode = code;
            setupStep = 'enterName';
            render();
            
            setTimeout(() => {
                const nameInput = document.getElementById('playerNameInput');
                if (nameInput) nameInput.focus();
            }, 100);
        }

        function joinGame() {
            const input = document.getElementById('playerNameInput');
            const name = input ? input.value.trim() : '';
            
            if (!name) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter your name';
                return;
            }
            
            socket.emit('joinGame', { gameCode, playerName: name });
        }

        function renderRoundSelector() {
            return `
                <div class="round-selector">
                    <button class="round-btn ${!isHost() ? 'disabled' : ''}" onclick="selectRound(0)">
                        <div class="round-title">Round 1</div>
                        <div>Connections</div>
                    </button>
                    <button class="round-btn ${!isHost() ? 'disabled' : ''}" onclick="selectRound(1)">
                        <div class="round-title">Round 2</div>
                        <div>Sequences</div>
                    </button>
                    <button class="round-btn ${!isHost() ? 'disabled' : ''}" onclick="selectRound(2)">
                        <div class="round-title">Round 3</div>
                        <div>Connecting Wall</div>
                    </button>
                    <button class="round-btn ${!isHost() ? 'disabled' : ''}" onclick="selectRound(3)">
                        <div class="round-title">Round 4</div>
                        <div>Missing Vowels</div>
                    </button>
                </div>
            `;
        }

        function renderQuestionSelector() {
            const questions = currentRound === 0 ? gameData.round1 : gameData.round2;
            const roundName = currentRound === 0 ? "Round 1: Connections" : "Round 2: Sequences";
            
            let html = `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">`;
            html += `<button class="back-btn ${!isHost() ? 'disabled' : ''}" onclick="backToRounds()">← Back to Rounds</button>`;
            html += `<div style="color: white; font-size: 1.25rem; font-weight: 600;">${roundName}</div>`;
            html += `<div style="width: 150px;"></div>`; // Spacer for centering
            html += `</div>`;
            
            html += '<div class="question-grid">';
            for (let i = 0; i < questions.length; i++) {
                const questionKey = `r${currentRound}q${i}`;
                const completed = completedQuestions.includes(questionKey);
                const isNextQuestion = (i === sequentialQuestionIndex);
                const canSelect = isHost() && isNextQuestion && !completed;
                const disabled = !canSelect ? 'disabled' : '';
                html += `<button class="question-btn ${completed ? 'completed' : ''} ${disabled}" ${canSelect ? `onclick="selectQuestion(${i})"` : ''}>Q${i + 1}</button>`;
            }
            html += '</div>';
            return html;
        }

        function renderClues() {
            const isSequence = currentRound === 1;
            const question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            const pointsValues = question.points;
            
            let html = '';
            const hideButton = cluesRevealed > 0 ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn ${!isHost() ? 'disabled' : ''}" onclick="backToQuestions()"${hideButton}>← Back to Questions</button>`;
            html += '<div class="clue-container"><div class="clue-grid">';
            
            for (let i = 0; i < 4; i++) {
                html += '<div class="clue-wrapper">';
                
                let showTimerOnThisClue;
                if (timerStopped && timerStoppedOnClue !== null) {
                    showTimerOnThisClue = (i === timerStoppedOnClue);
                } else {
                    showTimerOnThisClue = isSequence ? (i === cluesRevealed - 1 && cluesRevealed > 0 && i < 3) : (i === cluesRevealed - 1 && cluesRevealed > 0);
                }
                
                if (showTimerOnThisClue) {
                    html += `<div class="points-label">${pointsValues[i]} Point${pointsValues[i] !== 1 ? 's' : ''}</div>`;
                    html += `<div class="timer-bar-container"><div class="timer-bar" id="timerBar-${i}" style="width: 100%;"></div><div class="timer-text" id="timerText-${i}">60s</div></div>`;
                } else {
                    html += '<div class="timer-spacer"></div>';
                }
                
                const revealed = i < cluesRevealed;
                const canReveal = isSequence ? (i < 3 || timerStopped) : true;
                const clueText = revealed ? question.clues[i] : '';
                const classes = 'clue-btn' + (revealed ? ' revealed' : '') + (!isHost() ? ' disabled' : '');
                const onclick = (i === cluesRevealed && canReveal && isHost()) ? `onclick="revealClue(${i})"` : '';
                
                html += `<button class="${classes}" ${onclick}>${clueText}</button>`;
                html += '</div>';
            }
            html += '</div>';
            
            const answerText = isSequence ? question.answer : question.connection;
            const subtitle = isSequence ? question.sequence : '';
            html += '<div class="answer-box">';
            if (answerRevealed) {
                if (isSequence) {
                    html += `<div style="font-size: 1.25rem; font-weight: bold;">${subtitle}</div>`;
                } else {
                    html += `<div style="font-size: 1.25rem; font-weight: bold;">${answerText}</div>`;
                }
            } else if (isHost() && cluesRevealed > 0) {
                // Show answer to host only, with transparency
                const displayAnswer = isSequence ? subtitle : answerText;
                html += `<div style="font-size: 1.25rem; font-weight: bold; opacity: 0.3; color: #94a3b8;">${displayAnswer}</div>`;
            }
            html += '</div>';
            
            const buttonContainerClass = !isHost() ? 'buttons-container player-hidden' : 'buttons-container';
            html += `<div class="${buttonContainerClass}">`;
            if (timerStopped && !answerRevealed) {
                html += '<div class="button-row">';
                html += `<button class="btn btn-correct ${!isHost() ? 'disabled' : ''}" onclick="markCorrect()">Correct</button>`;
                html += `<button class="btn btn-incorrect ${!isHost() ? 'disabled' : ''}" onclick="markIncorrect()">Incorrect</button>`;
                html += '</div>';
            }
            if (answerRevealed) {
                html += `<button class="btn btn-primary ${!isHost() ? 'disabled' : ''}" onclick="completeQuestion()">Continue</button>`;
            }
            html += '</div>';
            
            // Timeout modal for Connections/Sequence rounds
            if (showCluesTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 200px;">';
                html += '<div class="time-up-title">Time is Up</div>';
                
                // Only show button for host
                if (isHost()) {
                    html += '<button class="btn btn-primary" onclick="dismissTimeUpModal()" style="font-size: 1.25rem; padding: 1rem 2rem; margin-top: 1.5rem;">Continue</button>';
                }
                
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function renderVowels() {
            const category = gameData.round4[vowelsCurrentCategory];
            const clue = category.clues[vowelsCurrentClue];
            
            let html = '';
            const hideButton = vowelsCategoryRevealed ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn ${!isHost() ? 'disabled' : ''}" onclick="backToRounds()"${hideButton}>← Back to Rounds</button>`;
            
            html += '<div class="timer-bar-container"><div id="timerBar" class="timer-bar" style="width: 100%;"></div><div id="timerText" class="timer-text">120s</div></div>';
            
            const allCluesComplete = vowelsCurrentClue === category.clues.length - 1 && vowelsAnswerRevealed;
            const canAdvanceCategory = allCluesComplete && vowelsCurrentCategory < gameData.round4.length - 1;
            const categoryDisabled = vowelsCategoryAnimating || (!canAdvanceCategory && vowelsCategoryRevealed) || !isHost();
            const categoryClasses = 'vowels-category-box' + (categoryDisabled ? ' disabled' : '');
            const categoryOnclick = !vowelsCategoryRevealed && isHost() ? ' onclick="revealCategoryAndStartTimer()"' : (canAdvanceCategory && !vowelsCategoryAnimating && isHost() ? ' onclick="nextVowelsCategory()"' : '');
            const categoryText = vowelsCategoryRevealed ? category.category : '';
            html += `<div class="${categoryClasses}"${categoryOnclick}>${categoryText}</div>`;
            
            html += '<div class="vowels-clue-box">';
            if (vowelsClueRevealed) {
                if (vowelsAnswerRevealed) {
                    html += createAnimatedClueText(clue.withoutVowels, clue.answer, true);
                } else {
                    html += `<div class="vowels-clue-text">${clue.withoutVowels}</div>`;
                    // Show answer to host only with transparency
                    if (isHost()) {
                        html += `<div style="font-size: 1.5rem; opacity: 0.3; color: #94a3b8; margin-top: 1rem;">${clue.answer}</div>`;
                    }
                }
            }
            html += '</div>';
            
            const buttonContainerClass = !isHost() ? 'buttons-container player-hidden' : 'buttons-container';
            html += `<div class="${buttonContainerClass}">`;
            // Show Correct/Incorrect buttons when timer is stopped and answer not revealed
            if (timerStopped && !vowelsAnswerRevealed && buzzedInPlayer) {
                html += '<div class="button-row">';
                html += `<button class="btn btn-correct ${!isHost() ? 'disabled' : ''}" onclick="markVowelsCorrect()">Correct</button>`;
                html += `<button class="btn btn-incorrect ${!isHost() ? 'disabled' : ''}" onclick="markVowelsIncorrect()">Incorrect</button>`;
                html += '</div>';
            } else if (vowelsAnswerRevealed) {
                // After timeout OR after completing all clues
                const timedOut = !vowelsClueRevealed; // If clue not revealed, it was a timeout
                
                if (timedOut || vowelsCurrentCategory >= gameData.round4.length - 1) {
                    // Show End Game if timed out OR on last category
                    html += `<button class="btn btn-primary ${!isHost() ? 'disabled' : ''}" onclick="endGame()">End Game</button>`;
                } else if (vowelsCurrentClue < category.clues.length - 1) {
                    // More clues in this category
                    html += `<button class="btn btn-primary ${!isHost() ? 'disabled' : ''}" onclick="nextVowelsClue()">Next Clue</button>`;
                }
            }
            html += '</div>';
            
            if (vowelsShowTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content">';
                html += '<div class="time-up-title">Time is Up</div>';
                html += `<button class="btn btn-primary ${!isHost() ? 'disabled' : ''}" onclick="revealVowelsAnswerFromModal()" style="font-size: 1.25rem; padding: 1rem 2rem;">End Game</button>`;
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function renderFinalScore() {
            return `
                <div class="final-score-container">
                    <div class="final-score-names">${playerNames}</div>
                    <div class="final-score-box">
                        <div class="final-score-value">${score}</div>
                    </div>
                    <button class="end-session-btn ${!isHost() ? 'disabled' : ''}" onclick="endSession()">End Session</button>
                </div>
            `;
        }

        function render() {
            const container = document.getElementById('gameContainer');
            let content = '';

            console.log('DEBUG render() - view:', view, 'currentRound:', currentRound);
            
            if (view === 'rounds') content = renderRoundSelector();
            else if (view === 'questions') content = renderQuestionSelector();
            else if (view === 'clues') content = renderClues();
            else if (view === 'wall') content = renderWall();
            else if (view === 'vowels') content = renderVowels();
            else if (view === 'finalScore') content = renderFinalScore();
            
            const buzzedIndicator = buzzedInPlayer ? `<span class="buzzed-indicator">${buzzedInPlayer} buzzed!</span>` : '';
            const headerClass = buzzedInPlayer ? 'header-title has-buzzer' : 'header-title';
            
            const headerHtml = view === 'finalScore' ? '' : `
                <div class="header-card">
                    <h1 class="${headerClass}">
                        ${playerNames}
                        ${buzzedIndicator}
                    </h1>
                    <div class="score-box">
                        <div class="score-value">${score}</div>
                    </div>
                </div>
            `;
            
            let categoryHtml = '';
            if (currentCategoryName && view !== 'rounds' && view !== 'questions' && view !== 'finalScore') {
                let displayText = currentCategoryName;
                
                // Add question number for Connections and Sequences rounds
                if (view === 'clues' && currentQuestion !== null) {
                    displayText += `<br>Question ${currentQuestion + 1}`;
                }
                
                categoryHtml = `<div class="category-display">${displayText}</div>`;
            }
            
            const setupModalHtml = renderSetupModal();
            
            container.innerHTML = `
                <div class="game-container">
                    ${headerHtml}
                    ${categoryHtml}
                    ${content}
                </div>
                ${setupModalHtml}
            `;
            
            // After innerHTML is set, if we're in wall view
            if (view === 'wall' && wallPhase === 'solving') {
                // Store initial positions
                const tiles = document.querySelectorAll('.wall-tile');
                const initialPositions = new Map();
                
                tiles.forEach(tile => {
                    const rect = tile.getBoundingClientRect();
                    const id = tile.getAttribute('data-tile-id');
                    initialPositions.set(id, { top: rect.top, left: rect.left });
                });
                
                // On next frame, check if positions changed
                requestAnimationFrame(() => {
                    tiles.forEach(tile => {
                        const id = tile.getAttribute('data-tile-id');
                        const oldPos = initialPositions.get(id);
                        const newRect = tile.getBoundingClientRect();
                        
                        if (oldPos && (oldPos.top !== newRect.top || oldPos.left !== newRect.left)) {
                            // Position changed, animate from old to new
                            const deltaX = oldPos.left - newRect.left;
                            const deltaY = oldPos.top - newRect.top;
                            
                            tile.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                            tile.style.transition = 'none';
                            
                            // Force reflow
                            tile.offsetHeight;
                            
                            // Animate to new position
                            tile.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                            tile.style.transform = '';
                        }
                    });
                });
            }

            if (view === 'clues' && timerStartTime !== null) updateTimer();
            if (view === 'wall' && wallPhase === 'solving' && timerStartTime !== null) updateTimer();
            if (view === 'vowels' && timerStartTime !== null) updateTimer();

            // After render, update timer display if it's stopped
            if (timerStopped && timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            }
        }

        // Initialize
        render();
    </script>
</body>
</html>