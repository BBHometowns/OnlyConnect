<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBH Only Connect</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: linear-gradient(to bottom right, #1e3a8a, #6b21a8, #1e3a8a);
            padding: 2rem;
        }

        .game-container {
            max-width: 64rem;
            margin: 0 auto;
        }

        .header-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title { 
            font-size: 1.875rem; 
            font-weight: bold; 
            color: white;
        }

        .header-title.has-buzzer {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .buzzed-indicator {
            display: inline-block;
            color: #fbbf24;
            font-size: 1.5rem;
            font-weight: 700;
            padding: 0.75rem 2rem;
            background: rgba(251, 191, 36, 0.3);
            border: 2px solid rgba(251, 191, 36, 0.6);
            border-radius: 0.5rem;
            animation: pulseGlow 1s ease-in-out infinite;
            text-align: center;
            min-width: 200px;
        }

        @keyframes pulseGlow {
            0%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px rgba(251, 191, 36, 0.8);
                background: rgba(251, 191, 36, 0.3);
            }
            50% {
                opacity: 0.9;
                text-shadow: 0 0 20px rgba(251, 191, 36, 1);
                background: rgba(251, 191, 36, 0.4);
            }
        }

        .category-display {
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            min-width: 150px;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .score-value {
            color: white;
            font-size: 3rem;
            font-weight: bold;
            line-height: 1;
        }

        .round-selector {
            display: grid;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .round-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .round-title {
            font-size: 0.875rem;
            opacity: 0.8;
            margin-bottom: 0.25rem;
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .question-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 2rem;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:active {
            transform: scale(1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn.completed {
            background: rgba(100, 100, 120, 0.4);
            border-color: rgba(100, 100, 120, 0.6);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .question-btn.completed:hover {
            transform: none;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .clue-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .buttons-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
            height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .buttons-container.player-hidden {
            display: none;
        }

        .timer-bar-container {
            height: 30px;
            background: #7f1d1d;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 0.5rem;
            position: relative;
            box-shadow: 0 5px 8px rgba(0, 0, 0, 0.4), 
                        inset 0 3px 0 rgba(0, 0, 0, 0.4),
                        inset 0 -2px 0 rgba(255, 255, 255, 0.2);
        }

        .timer-bar {
            height: 100%;
            background: #d1d5db;
            transition: width 0.1s linear;
            margin-left: auto;
            border-radius: 0;
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .points-label {
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            margin-bottom: 0.25rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .clue-wrapper {
            display: flex;
            flex-direction: column;
            min-height: 160px;
        }

        .timer-spacer {
            height: 60px;
            margin-bottom: 0rem;
        }

        .clue-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .clue-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 0.5rem;
            padding: 2rem 1rem;
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:hover:not(.revealed):not(.disabled) {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:active:not(.revealed):not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn.revealed {
            background: rgba(59, 130, 246, 0.4);
            border-color: #3b82f6;
            cursor: default;
        }

        .clue-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .answer-box {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            height: 80px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 1.5rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .button-row {
            display: flex;
            gap: 1rem;
        }

        .btn {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-correct {
            background: #22c55e;
            color: white;
        }

        .btn-correct:hover:not(.disabled) {
            background: #16a34a;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-incorrect {
            background: #ef4444;
            color: white;
        }

        .btn-incorrect:hover:not(.disabled) {
            background: #dc2626;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover:not(.disabled) {
            background: #2563eb;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 1.5rem;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:active:not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Connecting Wall Styles */
        .wall-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
            position: relative;
            min-height: 440px;
        }

        .wall-tile {
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(80, 80, 80, 1);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
            cursor: pointer;
            transition: top 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                        left 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        background 0.3s ease,
                        border-color 0.3s ease,
                        transform 0.2s ease,
                        align-items 0.3s ease,
                        padding-top 0.3s ease;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            position: absolute;
        }

        .wall-tile.text-up {
            align-items: flex-start;
            padding-top: 1.5rem;
        }

        .wall-tile:hover:not(.solved):not(.locked):not(.disabled) {
            transform: scale(1.05);
        }

        .wall-tile.selected {
            background: rgba(59, 130, 246, 0.6);
            border-color: rgba(59, 130, 246, 0.9);
            transform: scale(1.05);
        }

        .wall-tile.solved {
            cursor: default;
            pointer-events: none;
        }

        .wall-tile.locked {
            cursor: not-allowed;
        }

        .wall-tile.hidden-text {
            color: transparent;
        }

        .wall-tile.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .wall-tile.group-0 {
            background: rgba(250, 204, 21, 0.55);
            border-color: rgba(250, 204, 21, 0.95);
        }

        .wall-tile.group-1 {
            background: rgba(34, 197, 94, 0.55);
            border-color: rgba(34, 197, 94, 0.95);
        }

        .wall-tile.group-2 {
            background: rgba(59, 130, 246, 0.55);
            border-color: rgba(59, 130, 246, 0.95);
        }

        .wall-tile.group-3 {
            background: rgba(168, 85, 247, 0.55);
            border-color: rgba(168, 85, 247, 0.95);
        }

        .connection-display {
            position: absolute;
            left: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
            color: white;
            font-size: 0.875rem;
            font-weight: bold;
            z-index: 10;
            width: calc(100% - 4px);
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
        }

        .connection-display.fade-in {
            animation: fadeIn 1s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .time-up-modal, .wall-frozen-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .time-up-content, .wall-frozen-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        .time-up-title, .wall-frozen-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .guess-btn {
            width: 45px;
            height: 45px;
            border-radius: 0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .guess-btn.correct {
            background: rgba(34, 197, 94, 0.5);
            border-color: rgba(34, 197, 94, 0.8);
            color: white;
        }

        .guess-btn.incorrect {
            background: rgba(239, 68, 68, 0.5);
            border-color: rgba(239, 68, 68, 0.8);
            color: white;
        }

        .guess-btn:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .guess-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        .wall-timer-container {
            margin-top: 1rem;
            transition: opacity 0.5s ease;
        }

        .wall-timer-container.fade-out {
            opacity: 0;
        }

        .wall-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .lives-display {
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
        }

        /* Missing Vowels Styles */
        .vowels-category-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: bold;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .vowels-category-box:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-category-box.disabled {
            cursor: not-allowed;
        }

        .vowels-category-box.disabled:hover {
            transform: none;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-clue-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .vowels-clue-text {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.3em;
        }

        .vowels-letter {
            display: inline-block;
            transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .vowels-letter.spread {
            letter-spacing: 0.15em;
        }

        .vowels-letter.vowel {
            opacity: 0;
            transform: scale(0);
        }

        .vowels-letter.vowel.revealed {
            opacity: 1;
            transform: scale(1);
        }

        /* Final Score Screen */
        .final-score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
        }

        .final-score-names {
            color: white;
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }

        .final-score-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem 5rem;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .final-score-value {
            color: white;
            font-size: 6rem;
            font-weight: bold;
            line-height: 1;
        }

        .end-session-btn {
            margin-top: 2rem;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 1rem 3rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.25rem;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn:active:not(.disabled) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .end-session-btn.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Setup Modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .setup-modal-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
            min-width: 400px;
        }

        .setup-modal-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .setup-input {
            width: 100%;
            padding: 1rem;
            font-size: 1.25rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 1.5rem;
            outline: none;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .setup-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .setup-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .setup-btn {
            background: #3b82f6;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .setup-btn:hover {
            background: #2563eb;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .setup-btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .error-message {
            color: #ef4444;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            min-height: 1.5rem;
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <script>
        // Socket.IO connection
        const socket = io(window.location.origin);

        // Game data
        const gameData = {
            exampleRound1: { clues: ["Mercury", "Venus", "Earth", "Mars"], connection: "Rocky planets", points: [0, 0, 0, 0] },
            round1: [
                { clues: ["Zekrom & Reshiram", "Palkia & Dialga", "Groudon & Kyogre", "Lugia & Ho-oh"], connection: "Box Art Legendary Pokemon", points: [5, 3, 2, 1] },
                { clues: ["Sugar", "Eggs", "Cream Cheese", "Graham Cracker"], connection: "Core Cheesecake Ingredients", points: [5, 3, 2, 1] },
                { clues: ["Tyler Brown", "Ryan Lilly", "Kari Link", "Sam Focer"], connection: "HTL1 Winners: Team Boy George ...", points: [5, 3, 2, 1] },
                { clues: ["Morocco", "United Kingdom", "Andorra", "Portugal"], connection: "Countries That [Land] Border Spain", points: [5, 3, 2, 1] },
                { clues: ["Jasper", "Alice", "Alexa", "Siri"], connection: "AI Personal Assistants", points: [5, 3, 2, 1] },
                { clues: ["Montana", "Idaho", "Utah", "Nevada"], connection: "Interstate 15", points: [5, 3, 2, 1] }
            ],
            exampleRound2: { clues: ["1st", "2nd", "3rd", "4th"], answer: "4th", sequence: "Ordinal numbers", points: [0, 0, 0] },
            round2: [
                { clues: ["Vecepia Towery", "Sandra Diaz-Twine", "Danni Boatwright", "Sandra-Diaz Twine"], answer: "Sandra Diaz-Twine", sequence: "Every Other Female Survivor Winner", points: [5, 3, 2] },
                { clues: ["Max Teddy", "Sara Flanagan", "Justin Powell", "Megs Espinosa"], answer: "Megs Espinosa", sequence: "Successive Unanimous BBH Winners", points: [5, 3, 2] },
                { clues: ["The Silence Breakers", "The Guardians", ["<div style='font-size: 0.75rem; line-height 1.2;'>Joe Biden &<br>Kamala Harris</div>"], "The Spirit of Ukraine"], answer: "The Spirit of Ukraine", sequence: "Most Recent Non-Single Human Times Person of the Year Winners", points: [5, 3, 2] },
                { clues: ["117<br>Tennessine", "113<br>Nihonium", "115<br>Moscovium", "118<br>Oganesson"], answer: "118<br>Oganesson", sequence: "Most Recently Discovered Chemical Elements From Most Recent", points: [5, 3, 2] },
                { clues: ["Hyper", "Text", "Markup", "Language"], answer: "Language", sequence: "HTML acronym words", points: [5, 3, 2] },
                { clues: ["Delaware", "Pennsylvania", "New Jersey", "Georgia"], answer: "Georgia", sequence: "First Four States to Join the Union", points: [5, 3, 2] }
            ],
            round3: [
                {
                    groups: [
                        { items: ["Dragonite", "Hawlucha", "Starmie", "Gyarados"], connection: "Mega-Evolved Pokemon" },
                        { items: ["History Channel", "YouTube", "23andMe", "Pinsir"], connection: "Proper Nouns/Names with Pronouns Spelled/Said" },
                        { items: ["Lincoln", "Hoover", "Ford", "Johnson"], connection: "Presidents whose last name is also a company name" },
                        { items: ["Honda", "Dodge", "Maserati", "Ferrari"], connection: "Last Name-named car companies" }
                    ]
                }
            ],
            round4: [
                {
                    category: "GAMES ON BOARD GAME ARENA",
                    clues: [
                        { withoutVowels: "C DN MS", answer: "CODENAMES" },
                        { withoutVowels: "YK H M", answer: "YOKOHAMA" },
                        { withoutVowels: "CH NSC HC KRS", answer: "CHINESE CHECKERS" },
                        { withoutVowels: "GN T SFR D NT S", answer: "GO NUTS FOR DONUTS" }
                    ]
                },
                {
                    category: "COUNTRIES AND CAPITALS",
                    clues: [
                        { withoutVowels: "BN SRS RG NT N", answer: "BUENOS AIRES, ARGENTINA" },
                        { withoutVowels: "K LL MPR M LYS", answer: "KUALA LAMPUR, MALAYSIA" },
                        { withoutVowels: "BCH R STR MN", answer: "BUCHAREST, ROMANIA" },
                        { withoutVowels: "BD HBN TD R BMR TS", answer: "ABU DHABI, UNITED ARAB EMIRATES" }
                    ]
                },
                {
                    category: "BBH PROD MEMBERS",
                    clues: [
                        { withoutVowels: "JS HCN SL V", answer: "JOSH(UA) CONSALVO" },
                        { withoutVowels: "C RLL ND NC LRK", answer: "CARL LANDON CLARK" },
                        { withoutVowels: "S HL YK N N", answer: "ASHLEY KEENAN" },
                        { withoutVowels: "S TRL NGP RDNC", answer: "STERLING PRUDENCIO" }
                    ]
                },
                {
                    category: "GAMES CARL OR FOCER HAVE WON",
                    clues: [
                        { withoutVowels: "N STN CT", answer: "INSTINCT" },
                        { withoutVowels: "B G BRT HRH MT WNS", answer: "BIG BROTHER HOMETOWNS" },
                        { withoutVowels: "BT TLGR NDSS QDG M", answer: "BATTLEGROUNDS: SQUID GAME" },
                        { withoutVowels: "S BVR S NG RN DZR", answer: "SUBVERSION: GROUND ZERO" }
                    ]
                }
            ]
        };

        // Game state
        let myRole = null; // 'host' or 'player1', 'player2', etc.
        let gameCode = null;
        let playerNames = '';
        let allPlayers = []; // Array of all player names
        let showSetupModal = true;
        let setupStep = 'initial'; // 'initial', 'createGame', 'joinGame', 'enterName'
        let score = 0;
        let view = 'rounds';
        let currentRound = null;
        let currentQuestion = null;
        let cluesRevealed = 0;
        let answerRevealed = false;
        let completedQuestions = [];
        let sequentialQuestionIndex = 0; // Track which question we're on in sequential play
        let timerStartTime = null;
        let timerInterval = null;
        let timerDuration = 60000;
        let timerElapsedWhenStopped = 0;
        let timerStopped = false;
        let timerStoppedOnClue = null;
        let timerRemainingWhenStopped = null;
        let showCluesTimeUpModal = false;

        // Round 3 (Connecting Wall) state
        let wallTiles = [];
        let selectedTiles = [];
        let solvedGroups = [];
        let wallLives = 3;
        let wallPhase = 'setup'; // 'setup', 'solving', 'guessing', 'complete'
        let connectionGuesses = {};
        let wallTimerStarted = false;
        let showWallTimeUpModal = false;
        let showWallFrozenModal = false;
        let wallAnimations = new Map(); // Track tile positions for animations

        // Round 4 (Missing Vowels) state
        let vowelsCurrentCategory = 0;
        let vowelsCurrentClue = 0;
        let vowelsCategoryRevealed = false;
        let vowelsCategoryAnimating = false;
        let vowelsClueRevealed = false;
        let vowelsAnswerRevealed = false;
        let vowelsShowTimeUpModal = false;
        
        // Buzzer state
        let buzzedInPlayer = null;

        // Category display
        let currentCategoryName = '';

        // Socket event listeners
        socket.on('gameCreated', ({ gameCode: code, role }) => {
            gameCode = code;
            myRole = role;
            showSetupModal = false;
            render();
        });

        socket.on('gameJoined', ({ gameCode: code, role, playerName }) => {
            gameCode = code;
            myRole = role;
            playerNames = playerName;
            showSetupModal = false;
            render();
        });

        socket.on('secondaryHostJoined', ({ gameCode: code, role }) => {
            gameCode = code;
            myRole = role;
            showSetupModal = false;
            render();
        });

        socket.on('gameCodeExists', () => {
            alert('Game code already exists. Please choose another.');
        });

        socket.on('gameNotFound', () => {
            alert('Game not found. Please check the code.');
        });

        socket.on('playersUpdated', ({ players }) => {
            allPlayers = players;
            updatePlayerNamesDisplay();
            render();
        });

        socket.on('syncGameState', (gameState) => {
            console.log('DEBUG Received syncGameState - view:', gameState.view, 'wallTiles.length:', gameState.wallTiles ? gameState.wallTiles.length : 0);
            if (gameState.wallTiles && gameState.wallTiles.length > 0) {
                console.log('DEBUG First 3 wall tiles from sync:', gameState.wallTiles.slice(0, 3).map(t => t.text));
            }
            
            // Store the current timer state
            const wasTimerRunning = timerInterval !== null && !timerStopped;
            
            // Update all state from host
            score = gameState.score;
            view = gameState.view;
            currentRound = gameState.currentRound;
            currentQuestion = gameState.currentQuestion;
            cluesRevealed = gameState.cluesRevealed;
            answerRevealed = gameState.answerRevealed;
            completedQuestions = gameState.completedQuestions;
            timerStopped = gameState.timerStopped;
            timerElapsedWhenStopped = gameState.timerElapsedWhenStopped;
            timerStartTime = gameState.timerStartTime;
            timerDuration = gameState.timerDuration;
            timerStoppedOnClue = gameState.timerStoppedOnClue;
            timerRemainingWhenStopped = gameState.timerRemainingWhenStopped;
            buzzedInPlayer = gameState.buzzedInPlayer;
            showCluesTimeUpModal = gameState.showCluesTimeUpModal;
            
            // Wall state
            wallTiles = gameState.wallTiles;
            selectedTiles = gameState.selectedTiles;
            solvedGroups = gameState.solvedGroups;
            wallLives = gameState.wallLives;
            wallPhase = gameState.wallPhase;
            connectionGuesses = gameState.connectionGuesses;
            wallTimerStarted = gameState.wallTimerStarted;
            showTimeUpModal = gameState.showTimeUpModal;
            showWallFrozenModal = gameState.showWallFrozenModal;
            
            // Vowels state
            vowelsCurrentCategory = gameState.vowelsCurrentCategory;
            vowelsCurrentClue = gameState.vowelsCurrentClue;
            vowelsCategoryRevealed = gameState.vowelsCategoryRevealed;
            vowelsCategoryAnimating = gameState.vowelsCategoryAnimating;
            vowelsClueRevealed = gameState.vowelsClueRevealed;
            vowelsAnswerRevealed = gameState.vowelsAnswerRevealed;
            vowelsShowTimeUpModal = gameState.vowelsShowTimeUpModal;
            currentCategoryName = gameState.currentCategoryName || '';
            
            // Handle timer state
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // If timer is stopped and we have a frozen time, show it
            if (timerStopped && timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            } else if (!timerStopped && timerStartTime) {
                // Timer is running
                const now = Date.now();
                const elapsed = timerElapsedWhenStopped + (now - timerStartTime);
                const remaining = Math.max(0, timerDuration - elapsed);
                
                updateTimerDisplay(remaining);
                
                if (remaining > 0) {
                    timerInterval = setInterval(updateTimer, 100);
                }
            }
            
            render();
        });

        socket.on('playerBuzzed', ({ playerName }) => {
            buzzedInPlayer = playerName;
            if (isHost()) {
                // Stop timer when player buzzes
                stopTimer();
                render();
            } else {
                // On player side, just update the UI
                render();
            }
        });

        socket.on('gameAction', (action) => {
            // Players only - host ignores its own broadcasts
            if (isHost()) return;
            
            // Handle dismissTimeUpModal specifically
            if (action.type === 'dismissTimeUpModal') {
                showCluesTimeUpModal = false;
                render();
            } else if (typeof window[action.type] === 'function') {
                // Execute other actions
                window[action.type].apply(null, action.params || []);
            }
        });

        socket.on('wallAction', ({ action }) => {
            // Handle wall actions from players (only host processes these)
            if (myRole === 'host') {
                console.log('DEBUG HOST received wallAction:', action);
                if (action.type === 'toggleTile') {
                    toggleTile(action.tileId);
                } else if (action.type === 'checkGroup') {
                    checkGroup();
                }
            }
        });

        socket.on('playerToggleTile', ({ tileId }) => {
            console.log('DEBUG Host received playerToggleTile:', tileId);
            if (isHost()) {
                toggleTile(tileId);
            }
        });

        socket.on('playerClickedTile', ({ tileId }) => {
            console.log('DEBUG Received playerClickedTile event:', tileId, 'isHost:', isHost());
            if (isHost()) {
                console.log('DEBUG Host processing player tile click');
                toggleTile(tileId);
            }
        });

        socket.on('hostDisconnected', () => {
            alert('Host disconnected. Game session ended.');
            location.reload();
        });

        // Helper functions
        function isHost() {
            return myRole === 'host';
        }

        function isPlayer() {
            return myRole && myRole.startsWith('player');
        }

        function isSecondaryHost() {
            return myRole === 'secondaryHost';
        }

        function syncGameState() {
            if (!isHost()) return;
            
            const state = {
                // Basic game state
                score,
                view,
                currentRound,
                currentQuestion,
                currentCategoryName: currentCategoryName || '',
                
                // Clues state
                cluesRevealed,
                answerRevealed,
                completedQuestions,
                buzzedInPlayer,
                
                // Timer state
                timerStopped,
                timerElapsedWhenStopped,
                timerRemainingWhenStopped,
                timerStartTime,
                timerDuration,
                timerStoppedOnClue,
                
                // Modal states
                showCluesTimeUpModal,
                showTimeUpModal,
                showWallFrozenModal,
                vowelsShowTimeUpModal,
                
                // Wall state
                wallTiles,
                selectedTiles,
                solvedGroups,
                wallLives,
                wallPhase,
                connectionGuesses,
                wallTimerStarted,
                
                // Vowels state
                vowelsCurrentCategory,
                vowelsCurrentClue,
                vowelsCategoryRevealed,
                vowelsCategoryAnimating,
                vowelsClueRevealed,
                vowelsAnswerRevealed
            };
            
            socket.emit('syncState', state);
        }
        
        function broadcastAction(type, params = []) {
            if (!isHost()) return;
            socket.emit('hostAction', { type, params });
        }
        
        function updatePlayerNamesDisplay() {
            if (isHost() || isSecondaryHost()) {
                if (allPlayers.length === 0) {
                    playerNames = "Waiting for players...";
                } else if (allPlayers.length === 1) {
                    playerNames = allPlayers[0].name;
                } else if (allPlayers.length === 2) {
                    playerNames = allPlayers[0].name + " & " + allPlayers[1].name;
                } else {
                    const lastPlayer = allPlayers[allPlayers.length - 1].name;
                    const otherPlayers = allPlayers.slice(0, -1).map(p => p.name).join(", ");
                    playerNames = otherPlayers + ", & " + lastPlayer;
                }
            }
        }

        // Timer functions
        function startTimer() {
            if (timerStartTime === null) {
                // Reset all modal states when starting a new timer
                resetAllModals();
                
                // Reset timer state
                timerStartTime = Date.now();
                timerStopped = false;
                timerElapsedWhenStopped = 0;
                timerRemainingWhenStopped = null;  // Clear any frozen time
                
                // Start the timer
                timerInterval = setInterval(updateTimer, 100);
                
                // Sync the state if host
                if (isHost()) {
                    syncGameState();
                }
            }
        }
        
        function resetAllModals() {
            showTimeUpModal = false;
            showCluesTimeUpModal = false;
            vowelsShowTimeUpModal = false;
        }

        function updateTimer() {
            // Don't update if timer is stopped
            if (timerStopped) return;
            
            if (!timerStartTime) return;

            const now = Date.now();
            const elapsed = timerElapsedWhenStopped + (now - timerStartTime);
            const remaining = Math.max(0, timerDuration - elapsed);

            updateTimerDisplay(remaining);

            if (remaining <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;

                if (isHost()) {
                    handleTimerExpiration();
                }
            }
        }
        
        function updateTimerDisplay(remaining) {
            const percentage = (remaining / timerDuration) * 100;
            const seconds = Math.ceil(remaining / 1000);
            
            // Update all timer bars and texts (there might be multiple)
            for (let i = 0; i < 4; i++) {
                const timerBar = document.getElementById(`timerBar-${i}`);
                const timerText = document.getElementById(`timerText-${i}`);
                if (timerBar) timerBar.style.width = percentage + '%';
                if (timerText) timerText.textContent = seconds + 's';
            }
            
            // Also update the non-indexed ones for other rounds
            const mainTimerBar = document.getElementById('timerBar');
            const mainTimerText = document.getElementById('timerText');
            if (mainTimerBar) mainTimerBar.style.width = percentage + '%';
            if (mainTimerText) mainTimerText.textContent = seconds + 's';
        }

        function handleTimerExpiration() {
            if (!isHost()) return;
            
            // Set the appropriate modal flag based on current view
            if (view === 'clues') {
                showCluesTimeUpModal = true;
                timerStopped = true;
                timerRemainingWhenStopped = 0;  // Freeze at 0 when time expires
                
                // Lock the timer position when time expires
                if (timerStoppedOnClue === null) {
                    timerStoppedOnClue = Math.max(0, cluesRevealed - 1);
                }
            } else if (view === 'wall') {
                showWallFrozenModal = true;
                timerStopped = true;
            } else if (view === 'vowels') {
                vowelsShowTimeUpModal = true;
                timerStopped = true;
            }
            
            syncGameState();
            render();
        }

        function dismissTimeUpModal() {
            if (!isHost()) return;
            
            // Clear the modal flag
            showCluesTimeUpModal = false;
            
            // Make sure timer is fully stopped
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerStopped = true;
            
            // Sync state to all clients FIRST
            syncGameState();
            
            // Then broadcast the specific action
            broadcastAction('dismissTimeUpModal');
            
            // Finally render for host
            render();
        }
        
        function resetTimer() {
            // Clear any running timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Reset timer state
            timerStartTime = null;
            timerStopped = false;
            timerElapsedWhenStopped = 0;
            timerStoppedOnClue = null;
            timerRemainingWhenStopped = null;
            
            // Reset modal states
            showTimeUpModal = false;
            showCluesTimeUpModal = false;
            vowelsShowTimeUpModal = false;
            
            // If host, sync the state
            if (isHost()) {
                syncGameState();
            }
        }
        
        function stopTimer() {
            // First, capture the remaining time BEFORE clearing anything
            if (timerStartTime && !timerStopped) {
                const elapsed = timerElapsedWhenStopped + (Date.now() - timerStartTime);
                timerRemainingWhenStopped = Math.max(0, timerDuration - elapsed);
            }
            
            // Clear the interval
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Update elapsed time
            if (timerStartTime) {
                timerElapsedWhenStopped += Date.now() - timerStartTime;
                timerStartTime = null;
            }
            
            timerStopped = true;
            
            // Record which clue the timer stopped on (for clues view)
            if (view === 'clues' && timerStoppedOnClue === null) {
                timerStoppedOnClue = Math.max(0, cluesRevealed - 1);
            }
            
            // Update the display with the frozen time
            if (timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            }
            
            // Sync the state if host
            if (isHost()) {
                syncGameState();
            }
        }

        // Keyboard event listener for spacebar (players only)
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && isPlayer()) {
                if ((view === 'clues' && cluesRevealed > 0 && !timerStopped) ||
                    (view === 'vowels' && vowelsCategoryRevealed && vowelsClueRevealed && !timerStopped)) {
                    event.preventDefault();
                    socket.emit('buzzIn');
                }
            }
        });

        // Game functions with role restrictions
        function selectRound(roundIndex) {
            console.log('DEBUG selectRound called - isHost:', isHost(), 'roundIndex:', roundIndex);
            
            if (!isHost()) {
                console.log('DEBUG Non-host received selectRound - ignoring direct call, will receive via sync');
                return;
            }
            
            console.log('DEBUG Host selectRound - processing roundIndex:', roundIndex);
            
            currentRound = roundIndex;
            
            // Reset all modals when switching rounds
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            
            // Clear question state when changing rounds
            currentQuestion = null;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerStoppedOnClue = null;
            timerRemainingWhenStopped = null;
            buzzedInPlayer = null;
            resetTimer();
            
            if (roundIndex === 2) {
                console.log('DEBUG Host initializing Round 3: Wall');
                view = 'wall';
                currentCategoryName = "Connecting Wall";
                initializeWall();
            } else if (roundIndex === 3) {
                console.log('DEBUG Host initializing Round 4: Vowels');
                view = 'vowels';
                currentCategoryName = "Missing Vowels";
                initializeVowels();
            } else {
                // For rounds 0 (Connections) and 1 (Sequences)
                console.log('DEBUG Host initializing Round', roundIndex, '(Questions)');
                view = 'questions';
                currentCategoryName = '';
                
                // Set sequential index based on completed questions
                const questionsInRound = roundIndex === 0 ? gameData.round1.length : gameData.round2.length;
                sequentialQuestionIndex = 0;
                for (let i = 0; i < questionsInRound; i++) {
                    const questionKey = `r${roundIndex}q${i}`;
                    if (completedQuestions.includes(questionKey)) {
                        sequentialQuestionIndex = i + 1;
                    } else {
                        break;
                    }
                }
            }
            
            console.log('DEBUG After selectRound - view:', view, 'currentRound:', currentRound, 'wallTiles.length:', wallTiles.length);
            
            // Don't broadcast selectRound - just sync the full state
            syncGameState();
            render();
        }

        function selectQuestion(questionIndex) {
            if (!isHost()) return;
            
            const isExample = questionIndex === 'example';
            const questionKey = isExample ? `r${currentRound}qExample` : `r${currentRound}q${questionIndex}`;
            if (completedQuestions.includes(questionKey)) return;
            
            // Reset all relevant states
            currentQuestion = isExample ? 'example' : questionIndex;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerElapsedWhenStopped = 0;
            timerStartTime = null;
            timerStoppedOnClue = null;
            timerElapsedWhenStopped = null;
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            buzzedInPlayer = null;
            
            // Reset the timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Set category name and timer duration
            switch (currentRound) {
                case 0:
                    currentCategoryName = "Connections";
                    break;
                case 1:
                    currentCategoryName = "Sequences";
                    break;
            }
            
            // Set the view to 'clues' and timer duration
            view = 'clues';
            timerDuration = 60000; // 1 minute for each question
            
            // Sync the state with players
            syncGameState();
            render();
        }

        function revealClue(index) {
            if (!isHost()) return;
            
            const isSequence = currentRound === 1;
            
            if (index === cluesRevealed) {
                if (isSequence && index === 3 && !timerStopped) {
                    return;
                }
                
                cluesRevealed++;
                
                // Only start timer if not already stopped (by buzzer or timeout)
                if (!timerStopped && cluesRevealed < 4) {
                    startTimer();
                }
                
                broadcastAction('revealClue', [index]);
                syncGameState();
                render();
            }
        }

        function markCorrect() {
            if (!isHost()) return;
            
            const isExample = currentQuestion === 'example';
            const isSequence = currentRound === 1;
            let question;
            if (isExample) {
                question = isSequence ? gameData.exampleRound2 : gameData.exampleRound1;
            } else {
                question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            }
            const pointsValues = question.points;
            const pointsEarned = pointsValues[timerStoppedOnClue];
            
            // Only add points if not an example question
            if (!isExample) {
                score += pointsEarned;
            }
            answerRevealed = true;
            buzzedInPlayer = null;
            
            broadcastAction('markCorrect');
            syncGameState();
            render();
        }

        function markIncorrect() {
            if (!isHost()) return;
            
            answerRevealed = true;
            buzzedInPlayer = null;
            
            broadcastAction('markIncorrect');
            syncGameState();
            render();
        }

        // Player-side function to handle the broadcast
        function revealRemainingCluesFromPlayerSide() {
            // This will be called via gameAction broadcast
            // The state sync from host will handle everything
            render();
        }

        function completeQuestion() {
            if (!isHost()) return;
            
            console.log('DEBUG completeQuestion - currentRound:', currentRound, 'currentQuestion:', currentQuestion);
            
            const isExample = currentQuestion === 'example';
            const questionKey = isExample ? `r${currentRound}qExample` : `r${currentRound}q${currentQuestion}`;
            if (!completedQuestions.includes(questionKey)) {
                completedQuestions.push(questionKey);
            }
            
            // Reset all modals when completing a question
            showCluesTimeUpModal = false;
            showTimeUpModal = false;
            showWallFrozenModal = false;
            vowelsShowTimeUpModal = false;
            
            // Broadcast the completion
            broadcastAction('completeQuestion');
            
            // Auto-advance logic
            const questionsInCurrentRound = currentRound === 0 ? gameData.round1.length : gameData.round2.length;
            
            console.log('DEBUG questionsInCurrentRound:', questionsInCurrentRound);
            console.log('DEBUG isExample:', isExample);
            
            if (isExample) {
                // After example, move to first real question
                console.log('DEBUG Moving from example to first question');
                selectQuestion(0);
            } else if (currentQuestion < questionsInCurrentRound - 1) {
                // Move to next question in same round
                console.log('DEBUG Moving to next question:', currentQuestion + 1);
                selectQuestion(currentQuestion + 1);
            } else {
                // Finished round
                console.log('DEBUG Finished round', currentRound, '- moving to next round');
                
                if (currentRound === 0) {
                    // Move from Round 1 to Round 2
                    console.log('DEBUG Moving from Round 1 to Round 2');
                    sequentialQuestionIndex = 0;
                    selectRound(1);
                } else if (currentRound === 1) {
                    // Move from Round 2 to Round 3 (Wall)
                    console.log('DEBUG Moving from Round 2 to Round 3 (Wall)');
                    selectRound(2);
                } else {
                    // Shouldn't happen with current flow, but fallback
                    console.log('DEBUG Unexpected round completion - going back to rounds');
                    backToRounds();
                }
            }
        }

        function backToRounds() {
            if (!isHost()) return;
            
            view = 'rounds';
            currentRound = null;
            currentQuestion = null;
            resetTimer();
            
            broadcastAction('backToRounds');
            syncGameState();
            render();
        }

        function backToQuestions() {
            if (!isHost()) return;
            
            view = 'questions';
            currentQuestion = null;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerStoppedOnClue = null;
            showCluesTimeUpModal = false;
            buzzedInPlayer = null;
            resetTimer();
            
            broadcastAction('backToQuestions');
            syncGameState();
            render();
        }

        function endGame() {
            if (!isHost()) return;
            
            view = 'finalScore';
            
            broadcastAction('endGame');
            syncGameState();
            render();
        }

        function endSession() {
            if (!isHost()) return;
            
            location.reload();
        }

        // Round 4 (Missing Vowels) functions
        function initializeVowels() {
            vowelsCurrentCategory = 0;
            vowelsCurrentClue = 0;
            vowelsCategoryRevealed = false;
            vowelsCategoryAnimating = false;
            vowelsClueRevealed = false;
            vowelsAnswerRevealed = false;
            vowelsShowTimeUpModal = false;
            resetTimer();
            timerDuration = 120000;
        }

        function revealCategoryAndStartTimer() {
            if (!isHost()) return;
            
            if (!vowelsCategoryRevealed) {
                vowelsCategoryRevealed = true;
                vowelsCategoryAnimating = true;
                
                // Don't change currentCategoryName - keep it as "Missing Vowels"
                
                syncGameState();
                render();
                
                setTimeout(() => {
                    vowelsCategoryAnimating = false;
                    vowelsClueRevealed = true;
                    // Only start timer if it hasn't been started yet
                    if (timerStartTime === null) {
                        startTimer();
                    }
                    
                    broadcastAction('revealCategoryAndStartTimer');
                    syncGameState();
                    render();
                }, 3000);
            }
        }

        function markVowelsCorrect() {
            if (!isHost()) return;
            
            console.log('DEBUG markVowelsCorrect called');
            console.log('Timer stopped:', timerStopped);
            console.log('Buzzer cleared');
            
            score += 1;
            // ... rest of function
            vowelsAnswerRevealed = true;
            buzzedInPlayer = null;  // Clear the buzzer
            
            // DON'T restart timer here - it will restart when next clue is revealed
            
            setTimeout(() => {
                const clueElement = document.querySelector('.vowels-clue-text');
                if (clueElement) {
                    const letters = clueElement.querySelectorAll('.vowels-letter');
                    letters.forEach(letter => {
                        if (letter.classList.contains('vowel')) {
                            letter.classList.add('revealed');
                        }
                    });
                }
            }, 50);
            
            broadcastAction('markVowelsCorrect');
            syncGameState();
            render();
        }

        function markVowelsIncorrect() {
            if (!isHost()) return;
            
            vowelsAnswerRevealed = true;
            buzzedInPlayer = null;  // Clear the buzzer
            
            // DON'T restart timer here - it will restart when next clue is revealed
            
            setTimeout(() => {
                const clueElement = document.querySelector('.vowels-clue-text');
                if (clueElement) {
                    const letters = clueElement.querySelectorAll('.vowels-letter');
                    letters.forEach(letter => {
                        if (letter.classList.contains('vowel')) {
                            letter.classList.add('revealed');
                        }
                    });
                }
            }, 50);
            
            broadcastAction('markVowelsIncorrect');
            syncGameState();
            render();
        }

        function nextVowelsClue() {
            if (!isHost()) return;
            
            console.log('DEBUG nextVowelsClue called');
            console.log('Current category:', vowelsCurrentCategory);
            console.log('Current clue:', vowelsCurrentClue);
            console.log('Timer stopped:', timerStopped);
            console.log('Timer elapsed when stopped:', timerElapsedWhenStopped);
            console.log('Timer remaining when stopped:', timerRemainingWhenStopped);
            
            const category = gameData.round4[vowelsCurrentCategory];
            // ... rest of function
            
            if (vowelsCurrentClue < category.clues.length - 1) {
                vowelsCurrentClue++;
                vowelsClueRevealed = true;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;  // Clear buzzer for next clue
                
                // Restart the timer from where it was stopped
                if (timerStopped) {
                    timerStopped = false;
                    timerStartTime = Date.now();
                    timerRemainingWhenStopped = null;  // Clear the frozen time
                    // timerElapsedWhenStopped keeps its value to continue from where we left off
                    if (!timerInterval) {
                        timerInterval = setInterval(updateTimer, 100);
                    }
                }
                
                broadcastAction('nextVowelsClue');
                syncGameState();
                render();
            } else {
                // End of category - stop timer and show category complete state
                stopTimer();
                vowelsClueRevealed = false;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;
                
                syncGameState();
                render();
            }
        }

        function nextVowelsCategory() {
            if (!isHost()) return;
            
            const category = gameData.round4[vowelsCurrentCategory];
            
            // Only advance if we've completed all clues in current category
            if (vowelsCurrentClue !== category.clues.length - 1 || !vowelsAnswerRevealed) {
                return;
            }
            
            if (vowelsCurrentCategory < gameData.round4.length - 1) {
                vowelsCurrentCategory++;
                vowelsCurrentClue = 0;
                vowelsCategoryRevealed = true;
                vowelsCategoryAnimating = true;
                vowelsClueRevealed = false;
                vowelsAnswerRevealed = false;
                buzzedInPlayer = null;
                
                syncGameState();
                render();
                
                setTimeout(() => {
                    vowelsCategoryAnimating = false;
                    vowelsClueRevealed = true;
                    
                    // Restart timer from where it left off
                    if (timerStopped) {
                        timerStopped = false;
                        timerStartTime = Date.now();
                        timerRemainingWhenStopped = null;
                        // timerElapsedWhenStopped keeps its value
                        if (!timerInterval) {
                            timerInterval = setInterval(updateTimer, 100);
                        }
                    }
                    
                    broadcastAction('nextVowelsCategory');
                    syncGameState();
                    render();
                }, 3000);
            }
        }

        function revealVowelsAnswerFromModal() {
            if (!isHost()) return;
            
            vowelsShowTimeUpModal = false;
            
            // When time runs out, immediately move to end game state
            // Don't play through remaining clues
            vowelsClueRevealed = false;
            vowelsAnswerRevealed = true;
            stopTimer();
            
            broadcastAction('revealVowelsAnswerFromModal');
            syncGameState();
            render();
        }

        function isVowel(char) {
            return 'AEIOU'.includes(char.toUpperCase());
        }

        function createAnimatedClueText(withoutVowels, fullAnswer, revealed) {
            const answerChars = fullAnswer.split('');
            
            let html = '<div class="vowels-clue-text">';
            
            for (let i = 0; i < answerChars.length; i++) {
                const char = answerChars[i];
                
                if (char === ' ') {
                    html += '<span class="vowels-letter" style="width: 1em;"> </span>';
                } else if (isVowel(char)) {
                    const vowelClass = revealed ? 'vowels-letter vowel revealed' : 'vowels-letter vowel';
                    html += `<span class="${vowelClass}">${char}</span>`;
                } else {
                    html += `<span class="vowels-letter">${char}</span>`;
                }
            }
            
            html += '</div>';
            return html;
        }

        // Round 3 (Connecting Wall) functions
        function initializeWall() {
            // ONLY the host should shuffle tiles - players will receive the shuffled array via sync
            if (!isHost()) {
                console.log('DEBUG initializeWall called on non-host - skipping shuffle, will receive via sync');
                // Don't shuffle or create tiles - just initialize other state
                selectedTiles = [];
                solvedGroups = [];
                wallLives = 3;
                wallPhase = 'setup';
                connectionGuesses = {};
                wallTimerStarted = false;
                showWallTimeUpModal = false;
                showWallFrozenModal = false;
                resetTimer();
                timerDuration = 180000;
                return; // Exit early for non-hosts
            }
            
            const wallData = gameData.round3[0];
            
            console.log('DEBUG HOST initializeWall called');
            
            // Create tiles with unique IDs
            let allTiles = [];
            let tileId = 0;
            
            wallData.groups.forEach((group, groupIndex) => {
                group.items.forEach(item => {
                    allTiles.push({ 
                        id: tileId,
                        text: item, 
                        groupIndex: groupIndex,
                        solved: false,
                        position: tileId
                    });
                    tileId++;
                });
            });
            
            // Shuffle the tiles (HOST ONLY)
            wallTiles = shuffleArray(allTiles);
            
            // Re-assign positions after shuffle (0-15)
            wallTiles.forEach((tile, index) => {
                tile.position = index;
            });
            
            console.log('DEBUG HOST Wall initialized with', wallTiles.length, 'tiles');
            console.log('DEBUG HOST First 3 tiles:', wallTiles.slice(0, 3).map(t => t.text));
            
            selectedTiles = [];
            solvedGroups = [];
            wallLives = 3;
            wallPhase = 'setup';
            connectionGuesses = {};
            wallTimerStarted = false;
            showWallTimeUpModal = false;
            showWallFrozenModal = false;
            
            // Reset timer but don't start it
            resetTimer();
            timerDuration = 180000; // 3 minutes
        }

        function startWallTimer() {
            if (!isHost() || wallTimerStarted) return;
            
            wallTimerStarted = true;
            wallPhase = 'solving';
            startTimer();
            
            broadcastAction('startWallTimer');
            syncGameState();
            render();
        }

        function handleWallTimerExpired() {
            if (!isHost()) return;
            
            showWallTimeUpModal = true;
            timerStopped = true;
            
            syncGameState();
            render();
        }

        function toggleTile(tileId) {
            if (!wallTimerStarted) return;
            if (wallPhase !== 'solving') return;
            if (timerStopped) return;
            
            const tile = wallTiles.find(t => t.id === tileId);
            if (!tile || tile.solved) return;
            
            const selectedIndex = selectedTiles.indexOf(tileId);
            const element = document.querySelector(`[data-tile-id="${tileId}"]`);
            
            if (selectedIndex > -1) {
                // Deselect
                selectedTiles.splice(selectedIndex, 1);
                if (element) element.classList.remove('selected');
            } else {
                if (selectedTiles.length < 4) {
                    // Select
                    selectedTiles.push(tileId);
                    if (element) element.classList.add('selected');
                    
                    // Auto-submit when 4 tiles are selected
                    if (selectedTiles.length === 4) {
                        setTimeout(() => {
                            checkGroup();
                        }, 300);
                    }
                }
            }
            
            // Sync state but DON'T render
            if (isHost()) {
                syncGameState();
            }
        }

        function checkGroup() {
            if (selectedTiles.length !== 4) return;
            
            const selectedGroupIndices = selectedTiles.map(tileId => {
                const tile = wallTiles.find(t => t.id === tileId);
                return tile ? tile.groupIndex : -1;
            });
            const firstGroup = selectedGroupIndices[0];
            const allSame = selectedGroupIndices.every(g => g === firstGroup);
            
            if (allSame) {
                // Correct group!
                const wallData = gameData.round3[0];
                const groupItems = selectedTiles.map(tileId => {
                    const tile = wallTiles.find(t => t.id === tileId);
                    return tile ? tile.text : '';
                }).sort();
                
                // Mark tiles as solved
                selectedTiles.forEach(tileId => {
                    const tile = wallTiles.find(t => t.id === tileId);
                    if (tile) {
                        tile.solved = true;
                        tile.solvedGroupIndex = solvedGroups.length;
                    }
                });
                
                solvedGroups.push({
                    items: groupItems,
                    connection: wallData.groups[firstGroup].connection,
                    groupIndex: firstGroup,
                    solvedGroupIndex: solvedGroups.length
                });
                
                selectedTiles = [];
                score += 1;
                
                // Update positions WITHOUT calling render() - let CSS animate!
                updateTilePositionsInDOM();
                
                // If 3 groups found, auto-solve the 4th after animation
                if (solvedGroups.length === 3) {
                    setTimeout(() => {
                        autoSolveLastGroup();
                        // Move to guessing phase after final animation
                        setTimeout(() => {
                            wallPhase = 'guessing';
                            stopTimer();
                            if (isHost()) {
                                syncGameState();
                            }
                            render(); // Now we can render for guessing phase
                        }, 1000);
                    }, 800);
                } else {
                    // Sync state but DON'T render
                    if (isHost()) {
                        syncGameState();
                    }
                }
            } else {
                // Incorrect guess
                const remainingGroups = 4 - solvedGroups.length;
                
                // Deselect tiles visually without re-rendering
                selectedTiles.forEach(tileId => {
                    const element = document.querySelector(`[data-tile-id="${tileId}"]`);
                    if (element) {
                        element.classList.remove('selected');
                    }
                });
                selectedTiles = [];
                
                if (remainingGroups === 2) {
                    wallLives--;
                    
                    // Update lives display manually
                    const livesDisplay = document.querySelector('.lives-display');
                    if (livesDisplay) {
                        livesDisplay.innerHTML = `Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}`;
                    }
                    
                    if (wallLives === 0) {
                        stopTimer();
                        showWallFrozenModal = true;
                        
                        // Add modal to DOM manually
                        const gameContainer = document.querySelector('.game-container');
                        if (gameContainer) {
                            const modalHtml = `
                                <div class="wall-frozen-modal">
                                    <div class="wall-frozen-content">
                                        <div class="wall-frozen-title">The Wall has Frozen!</div>
                                        ${isHost() ? '<button class="btn btn-primary" onclick="resolveWallFrozen()">Resolve Wall</button>' : ''}
                                    </div>
                                </div>
                            `;
                            gameContainer.insertAdjacentHTML('beforeend', modalHtml);
                        }
                    }
                }
                
                if (isHost()) {
                    syncGameState();
                }
            }
        }

        function handleCorrectGroup() {
            const groupIndex = wallTiles.find(t => t.id === selectedTiles[0]).groupIndex;
            const wallData = gameData.round3[0];
            
            // Sort selected tiles alphabetically before marking as solved
            const sortedSelectedTiles = selectedTiles.slice().sort((aId, bId) => {
                const tileA = wallTiles.find(t => t.id === aId);
                const tileB = wallTiles.find(t => t.id === bId);
                return tileA.text.localeCompare(tileB.text);
            });
            
            // Mark tiles as solved
            sortedSelectedTiles.forEach(tileId => {
                const tile = wallTiles.find(t => t.id === tileId);
                tile.solved = true;
                tile.solvedGroupIndex = solvedGroups.length;
            });
            
            // Add to solved groups with sorted tiles
            solvedGroups.push({
                tiles: sortedSelectedTiles,
                groupIndex: groupIndex,
                connection: wallData.groups[groupIndex].connection
            });
            
            // Clear selection
            selectedTiles = [];
            score += 1;
            
            // Calculate and update new positions for ALL tiles
            let newPositionIndex = 0;
            
            // First, position all solved tiles (in order of groups solved)
            solvedGroups.forEach((group) => {
                group.tiles.forEach(tileId => {
                    const tile = wallTiles.find(t => t.id === tileId);
                    if (tile) {
                        tile.position = newPositionIndex;
                        newPositionIndex++;
                    }
                });
            });
            
            // Then, position all unsolved tiles
            wallTiles.forEach(tile => {
                if (!tile.solved) {
                    tile.position = newPositionIndex;
                    newPositionIndex++;
                }
            });
            
            // Now perform the animation by updating DOM without full re-render
            animateTilesToPositions();
            
            // Check if wall complete
            if (solvedGroups.length === 3) {
                // Auto-solve last group
                setTimeout(autoSolveLastGroup, 1000);
            }
            
            syncGameState();
            render();
        }

        function handleIncorrectGroup() {
            const remainingGroups = 4 - solvedGroups.length;
            
            if (remainingGroups === 2) {
                wallLives--;
                
                if (wallLives === 0) {
                    // Wall frozen
                    showWallFrozenModal = true;
                    stopTimer();
                }
            }
            
            selectedTiles = [];
            syncGameState();
            render();
        }

        function animateTilesToPositions() {
            // Get all tile elements
            const tileElements = document.querySelectorAll('.wall-tile');
            
            tileElements.forEach(element => {
                const tileId = element.getAttribute('data-tile-id');
                const tile = wallTiles.find(t => t.id === tileId);
                
                if (!tile) return;
                
                // Get current position
                const currentRect = element.getBoundingClientRect();
                const container = element.parentElement;
                const containerRect = container.getBoundingClientRect();
                
                // Calculate target position based on tile.position
                const targetRow = Math.floor(tile.position / 4);
                const targetCol = tile.position % 4;
                const targetTop = targetRow * 112;
                const targetLeft = `${targetCol * 25}%`;
                
                // Apply target position
                const oldTop = element.style.top;
                const oldLeft = element.style.left;
                
                element.style.top = targetTop + 'px';
                element.style.left = targetLeft;
                
                // Get new position in pixels
                const newRect = element.getBoundingClientRect();
                
                // Calculate the difference
                const deltaX = currentRect.left - newRect.left;
                const deltaY = currentRect.top - newRect.top;
                
                // Only animate if position actually changed
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    // Set transform to current position (before the style change)
                    element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    element.style.transition = 'none';
                    
                    // Force reflow
                    element.offsetHeight;
                    
                    // Animate to new position (which is now at 0,0 transform)
                    element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    element.style.transform = 'translate(0, 0)';
                }
                
                // Update solved class
                if (tile.solved) {
                    element.classList.add('solved', 'group-' + tile.solvedGroupIndex);
                    element.classList.remove('selected');
                }
            });
        }

        function autoSolveLastGroup() {
            const wallData = gameData.round3[0];
            
            // Find the one unsolved group
            for (let groupIndex = 0; groupIndex < 4; groupIndex++) {
                const alreadySolved = solvedGroups.some(g => g.groupIndex === groupIndex);
                
                if (!alreadySolved) {
                    const groupTiles = [];
                    
                    wallTiles.forEach((tile, index) => {
                        if (tile.groupIndex === groupIndex && !tile.solved) {
                            tile.solved = true;
                            tile.solvedGroupIndex = solvedGroups.length;
                            groupTiles.push(tile.text);
                        }
                    });
                    
                    if (groupTiles.length > 0) {
                        solvedGroups.push({
                            items: groupTiles.sort(),
                            connection: wallData.groups[groupIndex].connection,
                            groupIndex: groupIndex,
                            solvedGroupIndex: solvedGroups.length
                        });
                        
                        score += 1;
                        
                        // Update positions WITHOUT calling render() - let CSS animate!
                        updateTilePositionsInDOM();
                    }
                    break;
                }
            }
            
            if (isHost()) {
                syncGameState();
            }
        }
        
        function renderWall() {
            const remainingGroups = 4 - solvedGroups.length;
            const showLives = remainingGroups === 2 && wallPhase === 'solving' && wallTimerStarted;
            
            let html = '<div class="wall-header">';
            const hideButton = wallTimerStarted ? ' style="visibility: hidden;"' : '';
            
            // Back button (hidden during solving)
            if (wallPhase === 'setup') {
                html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToRounds()"> Back to Rounds</button>`;
            } else {
                html += '<div style="width: 150px;"></div>';
            }
            
            // Lives display
            if (showLives) {
                html += `<div class="lives-display">Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}</div>`;
            }
            
            html += '</div>';
            
            // Wall grid
            html += '<div class="wall-grid" style="position: relative; min-height: 440px;">';
            
            // Render each tile with calculated position
            wallTiles.forEach((tile) => {
                // Use tile.position directly (which was set during shuffle/rearrange)
                const pos = tile.position;
                const row = Math.floor(pos / 4);
                const col = pos % 4;
                
                // Calculate pixel positions (accounting for gaps)
                const tileWidth = 'calc((100% - 2.25rem) / 4)';
                const gapSize = 0.75; // rem
                const topPx = row * 100 + row * 12; // 100px height + 0.75rem gap (approx 12px)
                const leftCalc = `calc(${col} * ((100% - 2.25rem) / 4 + ${gapSize}rem))`;
                
                let classes = 'wall-tile';
                const isSelected = selectedTiles.includes(tile.id); // Use tile.id, not index
                
                // Add text-up class if this tile's group has a revealed connection
                const hasOverlay = tile.solved && wallPhase === 'guessing' && 
                                connectionGuesses[tile.solvedGroupIndex] && 
                                connectionGuesses[tile.solvedGroupIndex].revealed;
                if (hasOverlay) {
                    classes += ' text-up';
                }
                
                // Hide text until timer starts
                if (!wallTimerStarted) {
                    classes += ' hidden-text';
                }
                
                if (tile.solved) {
                    classes += ' solved group-' + tile.solvedGroupIndex;
                } else if (isSelected) {
                    classes += ' selected';
                } else if (wallPhase !== 'solving') {
                    classes += ' locked';
                }
                
                // For players, make tiles clickable; for host, tiles aren't directly clickable
                const canPlayerClick = isPlayer() && !tile.solved && wallPhase === 'solving' && wallTimerStarted && !timerStopped;
                const onclick = canPlayerClick ? `onclick="socket.emit('playerClickedTile', { tileId: ${tile.id} })"` : '';

                const style = `top: ${topPx}px; left: ${leftCalc}; width: ${tileWidth};`;

                html += `<button class="${classes}" ${onclick} style="${style}" data-tile-id="${tile.id}">${tile.text}</button>`;
            });
            
            // In guessing phase, add overlays and buttons on the actual grid
            if (wallPhase === 'guessing') {
                solvedGroups.forEach((group, idx) => {
                    const row = idx;
                    const topPx = row * 100 + row * 12;
                    
                    // Connection overlay (appears in lower half of the row)
                    if (connectionGuesses[idx] && connectionGuesses[idx].revealed) {
                        const overlayTop = topPx + 50; // Start at middle of tile
                        const fadeInClass = connectionGuesses[idx].justRevealed ? ' fade-in' : '';
                        const displayStyle = connectionGuesses[idx].justRevealed ? '' : ' opacity: 1;';
                        html += `<div class="connection-display${fadeInClass}" style="top: ${overlayTop}px;${displayStyle}">${group.connection}</div>`;
                    }
                    
                    // Guess buttons (to the right of the row, side by side)
                    if (!connectionGuesses[idx] && isHost()) {
                        // Buttons side by side, centered vertically in the row
                        const buttonsTop = topPx + 27; // Center in 100px row (50px - 45px/2)
                        html += `<div style="position: absolute; right: -120px; top: ${buttonsTop}px; display: flex; gap: 0.5rem;">`;
                        html += `<button class="guess-btn correct" onclick="guessConnection(${idx}, true)"></button>`;
                        html += `<button class="guess-btn incorrect" onclick="guessConnection(${idx}, false)"></button>`;
                        html += '</div>';
                    }
                });
            }
            
            html += '</div>'; // Close wall-grid
            
            // Show timer or start button during solving phase
            if (wallPhase === 'setup' && isHost()) {
                html += '<div style="text-align: center; margin-top: 2rem;">';
                html += '<button class="btn btn-primary" onclick="startWallTimer()">Start Timer</button>';
                html += '</div>';
            } else if (wallPhase === 'solving') {
                html += '<div class="timer-bar-container" style="margin-top: 1rem;">';
                html += '<div id="timerBar" class="timer-bar"></div>';
                html += '<div id="timerText" class="timer-text">180s</div>';
                html += '</div>';
            }
            
            // Continue button after all guessed
            if (wallPhase === 'guessing' && Object.keys(connectionGuesses).length === solvedGroups.length && isHost()) {
                html += '<div style="text-align: center; margin-top: 2rem;">';
                html += '<button class="btn btn-primary" onclick="selectRound(3)">Continue to Missing Vowels</button>';
                html += '</div>';
            }
            
            // Time up modal
            if (showTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content">';
                html += '<div class="time-up-title">Time is Up</div>';
                if (isHost()) {
                    html += '<button class="btn btn-primary" onclick="resolveWallTimeout()">Resolve Wall</button>';
                }
                html += '</div>';
                html += '</div>';
            }
            
            // Wall frozen modal
            if (showWallFrozenModal) {
                html += '<div class="wall-frozen-modal">';
                html += '<div class="wall-frozen-content">';
                html += '<div class="wall-frozen-title">The Wall has Frozen!</div>';
                if (isHost()) {
                    html += '<button class="btn btn-primary" onclick="resolveWallFrozen()">Resolve Wall</button>';
                }
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function guessConnection(groupIndex, isCorrect) {
            if (!isHost()) return;
            
            // Mark this specific guess with revealed flag (no justRevealed flag needed)
            connectionGuesses[groupIndex] = { 
                correct: isCorrect, 
                revealed: true
            };
            
            if (isCorrect) score += 1;
            
            // Check for bonus
            if (Object.keys(connectionGuesses).length === 4) {
                const allCorrect = Object.values(connectionGuesses).every(v => v.correct);
                const allFound = solvedGroups.every(g => !g.autoSolved);
                
                if (allCorrect && allFound) {
                    score += 2; // Bonus points
                }
            }
            
            syncGameState();
            render();
        }

        function renderWallTimeUpModal() {
            let html = '<div class="time-up-modal">';
            html += '<div class="time-up-content">';
            html += '<div class="time-up-title">Time is Up</div>';
            if (isHost()) {
                html += '<button class="btn btn-primary" onclick="resolveWallTimeout()">Resolve Wall</button>';
            }
            html += '</div></div>';
            return html;
        }

        function renderWallFrozenModal() {
            let html = '<div class="wall-frozen-modal">';
            html += '<div class="wall-frozen-content">';
            html += '<div class="wall-frozen-title">The Wall has Frozen!</div>';
            if (isHost()) {
                html += '<button class="btn btn-primary" onclick="resolveWallFrozen()">Resolve Wall</button>';
            }
            html += '</div></div>';
            return html;
        }

        function resolveWallTimeout() {
            if (!isHost()) return;
            showTimeUpModal = false;
            
            // Remove modal from DOM
            const modal = document.querySelector('.time-up-modal');
            if (modal) modal.remove();
            
            autoSolveRemainingGroups();
        }

        function resolveWallFrozen() {
            if (!isHost()) return;
            showWallFrozenModal = false;
            
            // Remove modal from DOM
            const modal = document.querySelector('.wall-frozen-modal');
            if (modal) modal.remove();
            
            autoSolveRemainingGroups();
        }

        function autoSolveRemainingGroups() {
            const wallData = gameData.round3[0];
            
            // Find all unsolved groups and mark them
            for (let groupIndex = 0; groupIndex < 4; groupIndex++) {
                const alreadySolved = solvedGroups.some(g => g.groupIndex === groupIndex);
                
                if (!alreadySolved) {
                    const groupTiles = [];
                    
                    wallTiles.forEach((tile, index) => {
                        if (tile.groupIndex === groupIndex && !tile.solved) {
                            tile.solved = true;
                            tile.solvedGroupIndex = solvedGroups.length;
                            groupTiles.push(tile.text);
                        }
                    });
                    
                    if (groupTiles.length > 0) {
                        solvedGroups.push({
                            items: groupTiles.sort(),
                            connection: wallData.groups[groupIndex].connection,
                            groupIndex: groupIndex,
                            solvedGroupIndex: solvedGroups.length,
                            autoSolved: true
                        });
                    }
                }
            }
            
            // Update positions WITHOUT calling render() - let CSS animate!
            updateTilePositionsInDOM();
            
            // Wait for animations to complete, then move to guessing phase
            setTimeout(() => {
                wallPhase = 'guessing';
                if (isHost()) {
                    syncGameState();
                }
                render(); // Now we can render for guessing phase
            }, 1000);
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Render functions
        function renderSetupModal() {
            if (!showSetupModal) return '';
            
            if (setupStep === 'initial') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Only Connect</div>
                            <button class="setup-btn" onclick="showHostPassword()">New Game (Host)</button>
                            <button class="setup-btn" onclick="showJoinGame()">Join Game (Player)</button>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'hostPassword') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Host Verification</div>
                            <p style="color: white; margin-bottom: 1rem; font-size: 0.875rem;">Enter production password to continue</p>
                            <input type="password" 
                                   id="passwordInput" 
                                   class="setup-input" 
                                   placeholder="Password" 
                                   onkeypress="if(event.key === 'Enter') verifyHostPassword()">
                            <button class="setup-btn" onclick="verifyHostPassword()">Verify</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'createGame') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Host Options</div>
                            <input type="text" 
                                id="gameCodeInput" 
                                class="setup-input" 
                                placeholder="Enter game code (e.g., Veto2)" 
                                onkeypress="if(event.key === 'Enter') createGame()">
                            <button class="setup-btn" onclick="createGame()">Create Game</button>
                            <button class="setup-btn" onclick="joinAsSecondaryHostWithCode()">Join as Secondary Host</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'joinGame') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Join Game</div>
                            <input type="text" 
                                   id="joinCodeInput" 
                                   class="setup-input" 
                                   placeholder="Enter game code" 
                                   onkeypress="if(event.key === 'Enter') proceedToName()">
                            <button class="setup-btn" onclick="proceedToName()">Next</button>
                            <button class="setup-btn" onclick="setupStep = 'initial'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            } else if (setupStep === 'enterName') {
                return `
                    <div class="setup-modal">
                        <div class="setup-modal-content">
                            <div class="setup-modal-title">Enter Your Name</div>
                            <input type="text" 
                                   id="playerNameInput" 
                                   class="setup-input" 
                                   placeholder="Your name" 
                                   onkeypress="if(event.key === 'Enter') joinGame()">
                            <button class="setup-btn" onclick="joinGame()">Join Game</button>
                            <button class="setup-btn" onclick="setupStep = 'joinGame'; render();" style="background: rgba(255, 255, 255, 0.15);">Back</button>
                            <div class="error-message" id="errorMessage"></div>
                        </div>
                    </div>
                `;
            }
        }

        function showHostPassword() {
            setupStep = 'hostPassword';
            render();
            setTimeout(() => {
                const input = document.getElementById('passwordInput');
                if (input) input.focus();
            }, 100);
        }

        function verifyHostPassword() {
            const input = document.getElementById('passwordInput');
            const password = input ? input.value : '';
            const correctPassword = 'Haych22'; // Change this to your desired password
            
            if (password === correctPassword) {
                showCreateGame();
            } else {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Incorrect password. Access denied.';
                setTimeout(() => {
                    setupStep = 'initial';
                    render();
                }, 2000);
            }
        }

        function showCreateGame() {
            setupStep = 'createGame';
            render();
            setTimeout(() => {
                const input = document.getElementById('gameCodeInput');
                if (input) input.focus();
            }, 100);
        }

        function showJoinGame() {
            setupStep = 'joinGame';
            render();
            setTimeout(() => {
                const input = document.getElementById('joinCodeInput');
                if (input) input.focus();
            }, 100);
        }

        function joinAsSecondaryHostWithCode() {
            const input = document.getElementById('gameCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            socket.emit('joinAsSecondaryHost', { gameCode: code });
        }

        function createGame() {
            const input = document.getElementById('gameCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            socket.emit('createGame', code);
        }

        function proceedToName() {
            const input = document.getElementById('joinCodeInput');
            const code = input ? input.value.trim() : '';
            
            if (!code) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter a game code';
                return;
            }
            
            gameCode = code;
            setupStep = 'enterName';
            render();
            
            setTimeout(() => {
                const nameInput = document.getElementById('playerNameInput');
                if (nameInput) nameInput.focus();
            }, 100);
        }

        function joinGame() {
            const input = document.getElementById('playerNameInput');
            const name = input ? input.value.trim() : '';
            
            if (!name) {
                const errorMsg = document.getElementById('errorMessage');
                if (errorMsg) errorMsg.textContent = 'Please enter your name';
                return;
            }
            
            socket.emit('joinGame', { gameCode, playerName: name });
        }

        function renderRoundSelector() {
            return `
                <div class="round-selector">
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(0)">
                        <div class="round-title">Round 1</div>
                        <div>Connections</div>
                    </button>
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(1)">
                        <div class="round-title">Round 2</div>
                        <div>Sequences</div>
                    </button>
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(2)">
                        <div class="round-title">Round 3</div>
                        <div>Connecting Wall</div>
                    </button>
                    <button class="round-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="selectRound(3)">
                        <div class="round-title">Round 4</div>
                        <div>Missing Vowels</div>
                    </button>
                </div>
            `;
        }

        function renderQuestionSelector() {
            const questions = currentRound === 0 ? gameData.round1 : gameData.round2;
            const roundName = currentRound === 0 ? "Round 1: Connections" : "Round 2: Sequences";
            const exampleKey = `r${currentRound}qExample`;
            const exampleCompleted = completedQuestions.includes(exampleKey);
            
            let html = `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">`;
            html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToRounds()"> Back to Rounds</button>`;
            html += `<div style="color: white; font-size: 1.25rem; font-weight: 600;">${roundName}</div>`;
            html += `<div style="width: 150px;"></div>`;
            html += `</div>`;
            
            // Example question box (above the grid)
            const canSelectExample = isHost() && !exampleCompleted && sequentialQuestionIndex === 0;
            const exampleDisabled = !canSelectExample ? 'disabled' : '';
            html += `<div style="margin-bottom: 1.5rem;">`;
            html += `<button class="question-btn ${exampleCompleted ? 'completed' : ''} ${exampleDisabled}" ${canSelectExample ? `onclick="selectQuestion('example')"` : ''} style="width: 100%;">Example Question</button>`;
            html += `</div>`;
            
            html += '<div class="question-grid">';
            for (let i = 0; i < questions.length; i++) {
                const questionKey = `r${currentRound}q${i}`;
                const completed = completedQuestions.includes(questionKey);
                const isNextQuestion = (i === sequentialQuestionIndex);
                const canSelect = isHost() && isNextQuestion && !completed;
                const disabled = !canSelect ? 'disabled' : '';
                html += `<button class="question-btn ${completed ? 'completed' : ''} ${disabled}" ${canSelect ? `onclick="selectQuestion(${i})"` : ''}>Q${i + 1}</button>`;
            }
            html += '</div>';
            return html;
        }

        function renderClues() {
            // Safety check
            if (currentQuestion === null || currentQuestion === undefined) {
                console.error('DEBUG renderClues called with null/undefined currentQuestion');
                return '<div style="color: white; text-align: center; margin-top: 2rem;">Loading question...</div>';
            }
            
            const isSequence = currentRound === 1;
            const isExample = currentQuestion === 'example';
            
            let question;
            if (isExample) {
                question = isSequence ? gameData.exampleRound2 : gameData.exampleRound1;
            } else {
                question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            }
            
            // Additional safety check
            if (!question) {
                console.error('DEBUG renderClues - question not found for currentQuestion:', currentQuestion, 'currentRound:', currentRound);
                return '<div style="color: white; text-align: center; margin-top: 2rem;">Question not found...</div>';
            }
            const pointsValues = question.points;
            
            let html = '';
            const hideButton = cluesRevealed > 0 ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToQuestions()"${hideButton}> Back to Questions</button>`;
            html += '<div class="clue-container"><div class="clue-grid">';
            
            for (let i = 0; i < 4; i++) {
                html += '<div class="clue-wrapper">';
                
                let showTimerOnThisClue;
                if (timerStopped && timerStoppedOnClue !== null) {
                    showTimerOnThisClue = (i === timerStoppedOnClue);
                } else {
                    showTimerOnThisClue = isSequence ? (i === cluesRevealed - 1 && cluesRevealed > 0 && i < 3) : (i === cluesRevealed - 1 && cluesRevealed > 0);
                }
                
                if (showTimerOnThisClue) {
                    html += `<div class="points-label">${pointsValues[i]} Point${pointsValues[i] !== 1 ? 's' : ''}</div>`;
                    html += `<div class="timer-bar-container"><div class="timer-bar" id="timerBar-${i}" style="width: 100%;"></div><div class="timer-text" id="timerText-${i}">60s</div></div>`;
                } else {
                    html += '<div class="timer-spacer"></div>';
                }
                
                const revealed = i < cluesRevealed;
                const canReveal = isSequence ? (i < 3 || timerStopped) : true;
                let clueText = revealed ? question.clues[i] : '';

                // For sequence round, show 4th clue transparently to host only
                if (isSequence && i === 3 && !revealed && isHost() && cluesRevealed > 0) {
                    clueText = `<div style="opacity: 0.3; color: #94a3b8;">${question.clues[3]}</div>`;
                }

                const classes = 'clue-btn' + (revealed ? ' revealed' : '') + (!isHost() ? ' disabled' : '');
                const onclick = (i === cluesRevealed && canReveal && isHost()) ? `onclick="revealClue(${i})"` : '';

                html += `<button class="${classes}" ${onclick}>${clueText}</button>`;
                html += '</div>';
            }
            html += '</div>';
            
            const answerText = isSequence ? question.answer : question.connection;
            const subtitle = isSequence ? question.sequence : '';
            html += '<div class="answer-box">';
            if (answerRevealed) {
                if (isSequence) {
                    html += `<div style="font-size: 1.25rem; font-weight: bold;">${subtitle}</div>`;
                } else {
                    html += `<div style="font-size: 1.25rem; font-weight: bold;">${answerText}</div>`;
                }
            } else if (isHost() && cluesRevealed > 0) {
                // Show answer to host only, with transparency
                const displayAnswer = isSequence ? subtitle : answerText;
                html += `<div style="font-size: 1.25rem; font-weight: bold; opacity: 0.3; color: #94a3b8;">${displayAnswer}</div>`;
            }
            html += '</div>';
            
            const buttonContainerClass = !isHost() || isSecondaryHost() ? 'buttons-container player-hidden' : 'buttons-container';
            html += `<div class="${buttonContainerClass}">`;
            if (timerStopped && !answerRevealed) {
                html += '<div class="button-row">';
                html += `<button class="btn btn-correct ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markCorrect()">Correct</button>`;
                html += `<button class="btn btn-incorrect ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markIncorrect()">Incorrect</button>`;
                html += '</div>';
            }
            if (answerRevealed) {
                html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="completeQuestion()">Continue</button>`;
            }
            html += '</div>';
            
            // Timeout modal for Connections/Sequence rounds
            if (showCluesTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 200px;">';
                html += '<div class="time-up-title">Time is Up</div>';
                
                // Only show button for host
                if (isHost()) {
                    html += '<button class="btn btn-primary" onclick="dismissTimeUpModal()" style="font-size: 1.25rem; padding: 1rem 2rem; margin-top: 1.5rem;">Continue</button>';
                }
                
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function renderVowels() {
            const category = gameData.round4[vowelsCurrentCategory];
            const clue = category.clues[vowelsCurrentClue];
            
            let html = '';
            const hideButton = vowelsCategoryRevealed ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="backToRounds()"${hideButton}> Back to Rounds</button>`;
            
            html += '<div class="timer-bar-container"><div id="timerBar" class="timer-bar" style="width: 100%;"></div><div id="timerText" class="timer-text">120s</div></div>';
            
            // Check if current category is complete (all clues answered)
            const categoryComplete = vowelsCurrentClue === category.clues.length - 1 && vowelsAnswerRevealed;
            const isLastCategory = vowelsCurrentCategory === gameData.round4.length - 1;
            const canAdvanceCategory = categoryComplete && !isLastCategory;
            
            // Category box - clickable only for first category reveal
            const categoryDisabled = vowelsCategoryAnimating || vowelsCategoryRevealed || !isHost();
            const categoryClasses = 'vowels-category-box' + (categoryDisabled ? ' disabled' : '');
            const categoryOnclick = !vowelsCategoryRevealed && isHost() ? ' onclick="revealCategoryAndStartTimer()"' : '';
            const categoryText = vowelsCategoryRevealed ? category.category : '';
            html += `<div class="${categoryClasses}"${categoryOnclick}>${categoryText}</div>`;
            
            html += '<div class="vowels-clue-box">';
            if (vowelsClueRevealed) {
                if (vowelsAnswerRevealed) {
                    html += createAnimatedClueText(clue.withoutVowels, clue.answer, true);
                } else {
                    html += `<div class="vowels-clue-text">${clue.withoutVowels}</div>`;
                    // Show answer to host only with transparency
                    if (isHost()) {
                        html += `<div style="font-size: 1.5rem; opacity: 0.3; color: #94a3b8; margin-top: 1rem;">${clue.answer}</div>`;
                    }
                }
            }
            html += '</div>';
            
            const buttonContainerClass = !isHost() || isSecondaryHost() ? 'buttons-container player-hidden' : 'buttons-container';
            html += `<div class="${buttonContainerClass}">`;
            
            // Show Correct/Incorrect buttons when timer is stopped and answer not revealed
            if (timerStopped && !vowelsAnswerRevealed && buzzedInPlayer) {
                html += '<div class="button-row">';
                html += `<button class="btn btn-correct ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markVowelsCorrect()">Correct</button>`;
                html += `<button class="btn btn-incorrect ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="markVowelsIncorrect()">Incorrect</button>`;
                html += '</div>';
            } 
            // After answer is revealed
            else if (vowelsAnswerRevealed) {
                // Check if there are more clues in this category
                if (vowelsCurrentClue < category.clues.length - 1) {
                    // More clues in this category - show Next Clue button
                    html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="nextVowelsClue()">Next Clue</button>`;
                } else if (canAdvanceCategory) {
                    // Finished this category, but more categories exist - show Next Category button
                    html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="nextVowelsCategory()">Next Category</button>`;
                } else if (isLastCategory && categoryComplete) {
                    // Finished last category - show End Game button
                    html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="endGame()">End Game</button>`;
                }
            }
            
            html += '</div>';
            
            // Time up modal
            if (vowelsShowTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content">';
                html += '<div class="time-up-title">Time is Up</div>';
                html += `<button class="btn btn-primary ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="revealVowelsAnswerFromModal()" style="font-size: 1.25rem; padding: 1rem 2rem;">End Game</button>`;
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function renderFinalScore() {
            return `
                <div class="final-score-container">
                    <div class="final-score-names">${playerNames}</div>
                    <div class="final-score-box">
                        <div class="final-score-value">${score}</div>
                    </div>
                    <button class="end-session-btn ${!isHost() || isSecondaryHost() ? 'disabled' : ''}" onclick="endSession()">End Session</button>
                </div>
            `;
        }

        function updateTilePositionsInDOM() {
            // Calculate NEW positions for all tiles based on solved state
            let newPositionIndex = 0;
            
            // First, update positions for all solved tiles (in order of groups solved)
            solvedGroups.forEach((group) => {
                group.items.forEach(itemText => {
                    const tile = wallTiles.find(t => t.text === itemText);
                    if (tile) {
                        tile.position = newPositionIndex;
                        newPositionIndex++;
                    }
                });
            });
            
            // Then, update positions for unsolved tiles
            wallTiles.forEach(tile => {
                if (!tile.solved) {
                    tile.position = newPositionIndex;
                    newPositionIndex++;
                }
            });
            
            console.log('DEBUG updateTilePositionsInDOM - updated positions for', wallTiles.length, 'tiles');
            
            // Update DOM elements directly (no re-render)
            wallTiles.forEach((tile) => {
                const element = document.querySelector(`[data-tile-id="${tile.id}"]`);
                if (!element) return;
                
                const pos = tile.position;
                const row = Math.floor(pos / 4);
                const col = pos % 4;
                
                const topPx = row * 100 + row * 12;
                const leftCalc = `calc(${col} * ((100% - 2.25rem) / 4 + 0.75rem))`;
                
                // Update position - CSS will animate this!
                element.style.top = topPx + 'px';
                element.style.left = leftCalc;
                
                // Update classes for solved tiles
                if (tile.solved) {
                    element.classList.add('solved', 'group-' + tile.solvedGroupIndex);
                    element.classList.remove('selected');
                }
            });
            
            // Update score display
            const scoreElement = document.querySelector('.score-value');
            if (scoreElement) scoreElement.textContent = score;
            
            // Update lives display if needed
            const remainingGroups = 4 - solvedGroups.length;
            if (remainingGroups === 2 && wallPhase === 'solving' && wallTimerStarted) {
                const wallHeader = document.querySelector('.wall-header');
                const existingLives = wallHeader?.querySelector('.lives-display');
                
                if (wallHeader && !existingLives) {
                    const livesHtml = `<div class="lives-display">Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}</div>`;
                    wallHeader.insertAdjacentHTML('beforeend', livesHtml);
                } else if (existingLives) {
                    existingLives.innerHTML = `Lives: ${''.repeat(wallLives)}${''.repeat(3 - wallLives)}`;
                }
            }
        }

        function render() {
            const container = document.getElementById('gameContainer');
            let content = '';

            console.log('DEBUG render() - view:', view, 'currentRound:', currentRound, 'currentQuestion:', currentQuestion);
            
            if (view === 'rounds') content = renderRoundSelector();
            else if (view === 'questions') content = renderQuestionSelector();
            else if (view === 'clues' && currentQuestion !== null) content = renderClues();
            else if (view === 'wall') content = renderWall();
            else if (view === 'vowels') content = renderVowels();
            else if (view === 'finalScore') content = renderFinalScore();
            else {
                // Fallback if view/question state is invalid
                console.warn('DEBUG Invalid view state - view:', view, 'currentQuestion:', currentQuestion);
                content = '<div style="color: white; text-align: center; margin-top: 2rem;">Loading...</div>';
            }
            
            const buzzedIndicator = buzzedInPlayer ? `<div style="position: absolute; left: 50%; transform: translateX(-50%);"><span class="buzzed-indicator">${buzzedInPlayer} buzzed in!</span></div>` : '';

            const headerHtml = view === 'finalScore' ? '' : `
                <div class="header-card" style="position: relative;">
                    <h1 class="header-title">${playerNames}</h1>
                    ${buzzedIndicator}
                    <div class="score-box">
                        <div class="score-value">${score}</div>
                    </div>
                </div>
            `;
            
            let categoryHtml = '';
            if (currentCategoryName && view !== 'rounds' && view !== 'questions' && view !== 'finalScore') {
                let displayText = currentCategoryName;
                
                // Add question number for Connections and Sequences rounds
                if (view === 'clues' && currentQuestion !== null) {
                    displayText += `<br>Question ${currentQuestion + 1}`;
                }
                
                categoryHtml = `<div class="category-display">${displayText}</div>`;
            }
            
            const setupModalHtml = renderSetupModal();
            
            container.innerHTML = `
                <div class="game-container">
                    ${headerHtml}
                    ${categoryHtml}
                    ${content}
                </div>
                ${setupModalHtml}
            `;
            
            if (view === 'clues' && timerStartTime !== null) updateTimer();
            if (view === 'wall' && wallPhase === 'solving' && timerStartTime !== null) updateTimer();
            if (view === 'vowels' && timerStartTime !== null) updateTimer();

            // After render, update timer display if it's stopped
            if (timerStopped && timerRemainingWhenStopped !== null) {
                updateTimerDisplay(timerRemainingWhenStopped);
            }
        }

        // Initialize
        render();
    </script>
</body>
</html>