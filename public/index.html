<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Only Connect Trivia Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: linear-gradient(to bottom right, #1e3a8a, #6b21a8, #1e3a8a);
            padding: 2rem;
        }

        .game-container {
            max-width: 64rem;
            margin: 0 auto;
        }

        .header-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title { 
            font-size: 1.875rem; 
            font-weight: bold; 
            color: white;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            min-width: 150px;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .score-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }

        .score-value {
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            line-height: 1;
        }

        .round-selector {
            display: grid;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .round-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .round-btn:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .round-title {
            font-size: 0.875rem;
            opacity: 0.8;
            margin-bottom: 0.25rem;
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .question-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 2rem;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn:active {
            transform: scale(1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .question-btn.completed {
            background: rgba(100, 100, 120, 0.4);
            border-color: rgba(100, 100, 120, 0.6);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .question-btn.completed:hover {
            transform: none;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .buttons-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 0.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
            height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timer-bar-container {
            height: 30px;
            background: #7f1d1d;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 0.5rem;
            position: relative;
            box-shadow: 0 5px 8px rgba(0, 0, 0, 0.4), 
                        inset 0 3px 0 rgba(0, 0, 0, 0.4),
                        inset 0 -2px 0 rgba(255, 255, 255, 0.2);
        }

        .timer-bar {
            height: 100%;
            background: #d1d5db;
            transition: width 0.1s linear;
            margin-left: auto;
            border-radius: 0;
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .points-label {
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            margin-bottom: 0.25rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .clue-wrapper {
            display: flex;
            flex-direction: column;
            min-height: 160px;
        }

        .timer-spacer {
            height: 60px;
            margin-bottom: 0rem;
        }

        .clue-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .clue-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 0.5rem;
            padding: 2rem 1rem;
            color: white;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:hover:not(.revealed) {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn:active:not(.revealed) {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .clue-btn.revealed {
            background: rgba(59, 130, 246, 0.4);
            border-color: #3b82f6;
            cursor: default;
        }

        /* ANSWER BOX - ALWAYS VISIBLE */
        .answer-box {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1.5rem;
            color: white;
            height: 80px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 1.5rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .button-row {
            display: flex;
            gap: 1rem;
        }

        .btn {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-correct {
            background: #22c55e;
            color: white;
        }

        .btn-correct:hover {
            background: #16a34a;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-incorrect {
            background: #ef4444;
            color: white;
        }

        .btn-incorrect:hover {
            background: #dc2626;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 1.5rem;
            transition: all 0.2s;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .back-btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
        }

        /* Connecting Wall Styles */
        .wall-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
            position: relative;
            min-height: 440px; /* Fixed height to prevent jumping */
        }

        .wall-tile {
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(80, 80, 80, 1);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
            cursor: pointer;
            transition: top 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                        left 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        background 0.3s ease,
                        border-color 0.3s ease,
                        transform 0.2s ease,
                        align-items 0.3s ease,
                        padding-top 0.3s ease;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
            position: absolute;
        }

        .wall-tile.text-up {
            align-items: flex-start;
            padding-top: 1.5rem;
        }

        .wall-tile:hover:not(.solved):not(.locked) {
            transform: scale(1.05);
        }

        .wall-tile.selected {
            background: rgba(59, 130, 246, 0.6);
            border-color: rgba(59, 130, 246, 0.9);
            transform: scale(1.05);
        }

        .wall-tile.solved {
            cursor: default;
            pointer-events: none;
        }

        .wall-tile.locked {
            cursor: not-allowed;
        }

        .wall-tile.hidden-text {
            color: transparent;
        }

        /* Connection group colors - More vibrant */
        .wall-tile.group-0 {
            background: rgba(250, 204, 21, 0.55);
            border-color: rgba(250, 204, 21, 0.95);
        }

        .wall-tile.group-1 {
            background: rgba(34, 197, 94, 0.55);
            border-color: rgba(34, 197, 94, 0.95);
        }

        .wall-tile.group-2 {
            background: rgba(59, 130, 246, 0.55);
            border-color: rgba(59, 130, 246, 0.95);
        }

        .wall-tile.group-3 {
            background: rgba(168, 85, 247, 0.55);
            border-color: rgba(168, 85, 247, 0.95);
        }

        .solved-group {
            position: relative;
            min-height: 100px;
            margin-bottom: 0.75rem;
        }

        .connection-display {
            position: absolute;
            left: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
            color: white;
            font-size: 0.875rem;
            font-weight: bold;
            z-index: 10;
            width: calc(100% - 4px);
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
        }

        .connection-display.fade-in {
            animation: fadeIn 1s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .guess-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            opacity: 0;
            animation: fadeInButtons 0.5s ease 2s forwards;
        }

        @keyframes fadeInButtons {
            to {
                opacity: 1;
            }
        }

        .time-up-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .wall-frozen-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .time-up-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
        }

        .wall-frozen-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 3rem;
            text-align: center;
            color: white;
        }

        .time-up-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .wall-frozen-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }

        .guess-btn {
            width: 45px;
            height: 45px;
            border-radius: 0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .guess-btn.correct {
            background: rgba(34, 197, 94, 0.5);
            border-color: rgba(34, 197, 94, 0.8);
            color: white;
        }

        .guess-btn.incorrect {
            background: rgba(239, 68, 68, 0.5);
            border-color: rgba(239, 68, 68, 0.8);
            color: white;
        }

        .guess-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.5), 
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.3);
        }

        .wall-timer-container {
            margin-top: 1rem;
            transition: opacity 0.5s ease;
        }

        .wall-timer-container.fade-out {
            opacity: 0;
        }

        .wall-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .lives-display {
            color: white;
            font-size: 1.125rem;
            font-weight: bold;
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <script>
        // Game data
        const gameData = {
            round1: [
                { clues: ["Mercury", "Venus", "Earth", "Mars"], connection: "Rocky planets in our solar system", points: [5, 3, 2, 1] },
                { clues: ["Pride", "Envy", "Wrath", "Sloth"], connection: "Seven deadly sins", points: [5, 3, 2, 1] },
                { clues: ["John", "Paul", "George", "Ringo"], connection: "Members of The Beatles", points: [5, 3, 2, 1] },
                { clues: ["Spring", "Summer", "Autumn", "Winter"], connection: "Four seasons", points: [5, 3, 2, 1] },
                { clues: ["Diamond", "Ruby", "Emerald", "Sapphire"], connection: "Precious gemstones", points: [5, 3, 2, 1] },
                { clues: ["North", "South", "East", "West"], connection: "Cardinal directions", points: [5, 3, 2, 1] }
            ],
            round2: [
                { clues: ["1st", "2nd", "3rd", "?"], answer: "4th", sequence: "Ordinal numbers", points: [5, 3, 2] },
                { clues: ["Bronze", "Silver", "Gold", "?"], answer: "Platinum", sequence: "Record certification levels", points: [5, 3, 2] },
                { clues: ["A", "E", "I", "?"], answer: "O", sequence: "Vowels in alphabetical order", points: [5, 3, 2] },
                { clues: ["Washington", "Adams", "Jefferson", "?"], answer: "Madison", sequence: "US Presidents in order", points: [5, 3, 2] },
                { clues: ["90¬∞", "180¬∞", "270¬∞", "?"], answer: "360¬∞", sequence: "Quarter rotations", points: [5, 3, 2] },
                { clues: ["New Moon", "First Quarter", "Full Moon", "?"], answer: "Last Quarter", sequence: "Phases of the moon", points: [5, 3, 2] }
            ],
            round3: [
                {
                    groups: [
                        { items: ["Bark", "Trunk", "Branch", "Root"], connection: "Parts of a tree" },
                        { items: ["Jupiter", "Saturn", "Uranus", "Neptune"], connection: "Gas giant planets" },
                        { items: ["Red", "Blue", "Green", "Yellow"], connection: "Primary and secondary colors" },
                        { items: ["Apple", "Microsoft", "Amazon", "Google"], connection: "Tech companies" }
                    ]
                }
            ]
        };

        // Game state
        let score = 0;
        let view = 'rounds';
        let currentRound = null;
        let currentQuestion = null;
        let cluesRevealed = 0;
        let answerRevealed = false;
        let completedQuestions = [];
        let timerStartTime = null;
        let timerInterval = null;
        let timerDuration = 60000;
        let timerElapsedWhenStopped = 0;
        let timerStopped = false;
        let timerStoppedOnClue = null; // Track which clue index the timer was stopped on

        // Round 3 (Connecting Wall) state
        let wallTiles = [];
        let selectedTiles = [];
        let solvedGroups = [];
        let wallLives = 3;
        let wallLocked = false;
        let wallTimerStarted = false;
        let wallPhase = 'solving'; // 'solving' or 'guessing'
        let connectionGuesses = []; // Track which connections have been guessed
        let wallTimerReady = false; // Track if timer has been started by user
        let showTimeUpModal = false; // Track if we should show the time up modal
        let showWallFrozenModal = false; // Track if we should show the wall frozen modal

        const roundNames = ["Connections", "Sequences", "Connecting Wall", "Missing Vowels"];

        function startTimer() {
            if (timerStartTime === null) {
                timerStartTime = Date.now();
                timerInterval = setInterval(updateTimer, 100);
            }
        }

        function updateTimer() {
            if (timerStopped) {
                const remaining = Math.max(0, timerDuration - timerElapsedWhenStopped);
                const percentage = (remaining / timerDuration) * 100;
                const timerBar = document.getElementById('timerBar');
                const timerText = document.getElementById('timerText');
                if (timerBar) timerBar.style.width = percentage + '%';
                if (timerText) timerText.textContent = Math.ceil(remaining / 1000) + 's';
                return;
            }
            
            const elapsed = Date.now() - timerStartTime;
            const remaining = Math.max(0, timerDuration - elapsed);
            const percentage = (remaining / timerDuration) * 100;
            const timerBar = document.getElementById('timerBar');
            const timerText = document.getElementById('timerText');
            if (timerBar) timerBar.style.width = percentage + '%';
            if (timerText) timerText.textContent = Math.ceil(remaining / 1000) + 's';
            if (remaining === 0) stopTimer();
        }

        function stopTimer() {
            if (timerInterval) {
                if (!timerStopped && timerStartTime !== null) {
                    timerElapsedWhenStopped = Date.now() - timerStartTime;
                    timerStoppedOnClue = cluesRevealed - 1; // Record which clue we stopped on
                }
                clearInterval(timerInterval);
                timerInterval = null;
                timerStopped = true;
                
                // If we're in the wall and timer runs out, show modal
                if (view === 'wall' && wallPhase === 'solving') {
                    showTimeUpModal = true;
                }
                
                render();
            }
        }

        function resetTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            timerStartTime = null;
            timerStopped = false;
            timerElapsedWhenStopped = 0;
            timerStoppedOnClue = null;
        }

        function markCorrect() {
            const isSequence = currentRound === 1;
            const question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            const pointsValues = question.points;
            // Use the clue index where timer was stopped for points
            const pointsEarned = pointsValues[timerStoppedOnClue];
            score += pointsEarned;
            answerRevealed = true;
            render();
        }

        function markIncorrect() {
            answerRevealed = true;
            render();
        }

        function completeQuestion() {
            const questionKey = `r${currentRound}q${currentQuestion}`;
            if (!completedQuestions.includes(questionKey)) {
                completedQuestions.push(questionKey);
            }
            backToQuestions();
        }

        // Keyboard event listener for spacebar
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && view === 'clues' && cluesRevealed > 0 && !timerStopped) {
                event.preventDefault();
                stopTimer();
            }
        });

        function selectRound(roundIndex) {
            currentRound = roundIndex;
            
            // Round 3 (Connecting Wall) goes straight to the wall
            if (roundIndex === 2) {
                initializeWall();
                view = 'wall';
            } else {
                view = 'questions';
            }
            
            render();
        }

        // Connecting Wall Functions
        function initializeWall() {
            const wallData = gameData.round3[0];
            
            // Flatten all items from all groups
            let allItems = [];
            wallData.groups.forEach((group, groupIndex) => {
                group.items.forEach(item => {
                    allItems.push({ text: item, groupIndex: groupIndex });
                });
            });
            
            // Shuffle the items
            wallTiles = shuffleArray(allItems);
            selectedTiles = [];
            solvedGroups = [];
            wallLives = 3;
            wallLocked = false;
            wallPhase = 'solving';
            connectionGuesses = [];
            wallTimerReady = false;
            
            // Reset timer but don't start it
            resetTimer();
            timerDuration = 180000; // 3 minutes
        }

        function startWallTimer() {
            if (!wallTimerReady) {
                wallTimerReady = true;
                startTimer();
                render();
            }
        }

        function resolveWallAfterTimeout() {
            showTimeUpModal = false;
            
            // Remove modal from DOM
            const modal = document.querySelector('.time-up-modal');
            if (modal) modal.remove();
            
            // Auto-solve remaining groups with sliding animation
            autoSolveRemainingGroups();
            
            // Wait for animations to complete (800ms), then move to guessing phase
            setTimeout(() => {
                wallPhase = 'guessing';
                render(); // This will show the guess buttons with fade-in animation
            }, 1000);
        }

        function resolveWallAfterFrozen() {
            showWallFrozenModal = false;
            
            // Remove modal from DOM
            const modal = document.querySelector('.wall-frozen-modal');
            if (modal) modal.remove();
            
            // Fade out timer
            const timerContainer = document.querySelector('.wall-timer-container');
            if (timerContainer) {
                timerContainer.classList.add('fade-out');
                
                // Remove timer after fade completes
                setTimeout(() => {
                    if (timerContainer) timerContainer.remove();
                }, 500);
            }
            
            // Auto-solve remaining groups with sliding animation
            autoSolveRemainingGroups();
            
            // Wait for animations to complete (800ms), then move to guessing phase
            setTimeout(() => {
                wallPhase = 'guessing';
                render(); // This will show the guess buttons with fade-in animation
            }, 1000);
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function toggleTile(index) {
            if (!wallTimerReady) return; // Can't select tiles until timer starts
            if (wallPhase !== 'solving') return;
            if (timerStopped) return;
            
            const tile = wallTiles[index];
            if (tile.solved) return;
            
            const selectedIndex = selectedTiles.indexOf(index);
            const element = document.querySelector(`[data-tile-id="${index}"]`);
            
            if (selectedIndex > -1) {
                // Deselect
                selectedTiles.splice(selectedIndex, 1);
                if (element) element.classList.remove('selected');
            } else {
                if (selectedTiles.length < 4) {
                    // Select
                    selectedTiles.push(index);
                    if (element) element.classList.add('selected');
                    
                    // Auto-submit when 4 tiles are selected
                    if (selectedTiles.length === 4) {
                        setTimeout(() => checkGroup(), 300);
                    }
                }
            }
        }

        function updateLivesDisplay() {
            const remainingGroups = 4 - solvedGroups.length;
            const livesContainer = document.querySelector('.wall-header');
            if (!livesContainer) return;
            
            // Remove existing lives display
            const existingLives = livesContainer.querySelector('.lives-display');
            if (existingLives) {
                existingLives.remove();
            }
            
            // Add lives display if we're down to 2 groups
            if (remainingGroups === 2 && wallPhase === 'solving' && wallTimerReady) {
                const livesHtml = `<div class="lives-display">Lives: ${'‚ù§Ô∏è'.repeat(wallLives)}${'üñ§'.repeat(3 - wallLives)}</div>`;
                livesContainer.insertAdjacentHTML('beforeend', livesHtml);
            }
        }

        function checkGroup() {
            if (selectedTiles.length !== 4) return;
            
            const selectedGroupIndices = selectedTiles.map(i => wallTiles[i].groupIndex);
            const firstGroup = selectedGroupIndices[0];
            const allSame = selectedGroupIndices.every(g => g === firstGroup);
            
            if (allSame) {
                // Correct group!
                const wallData = gameData.round3[0];
                const groupItems = selectedTiles.map(i => wallTiles[i].text).sort();
                
                // Mark tiles as solved and assign to solved group
                selectedTiles.forEach(i => {
                    wallTiles[i].solved = true;
                    wallTiles[i].solvedGroupIndex = solvedGroups.length;
                });
                
                solvedGroups.push({
                    items: groupItems,
                    connection: wallData.groups[firstGroup].connection,
                    groupIndex: firstGroup,
                    solvedGroupIndex: solvedGroups.length
                });
                
                selectedTiles = [];
                
                // Award 1 point for finding the group
                score += 1;
                
                // Update score display only (don't re-render entire grid)
                const scoreElement = document.querySelector('.score-value');
                if (scoreElement) scoreElement.textContent = score;
                
                // Update lives display if needed
                updateLivesDisplay();
                
                // Update tile positions smoothly WITHOUT re-rendering
                updateTilePositions();
                
                // If 3 groups found, auto-solve the 4th
                if (solvedGroups.length === 3) {
                    setTimeout(() => {
                        autoSolveLastGroup();
                        // Wait for animation, then show guessing phase with button fade-in
                        setTimeout(() => {
                            endWallSolving();
                        }, 1000);
                    }, 800);
                } else if (solvedGroups.length === 4) {
                    // All groups found - wait for animation, then show guessing phase
                    setTimeout(() => {
                        endWallSolving();
                    }, 1000);
                }
            } else {
                // Incorrect - only lose lives when 2 groups remain
                const remainingGroups = 4 - solvedGroups.length;
                
                // Deselect tiles visually
                selectedTiles.forEach(idx => {
                    const element = document.querySelector(`[data-tile-id="${idx}"]`);
                    if (element) {
                        element.classList.remove('selected');
                    }
                });
                selectedTiles = [];
                
                if (remainingGroups === 2) {
                    wallLives--;
                    updateLivesDisplay();
                    
                    if (wallLives === 0) {
                        // Stop the timer
                        if (timerInterval) {
                            clearInterval(timerInterval);
                            timerInterval = null;
                            timerStopped = true;
                        }
                        
                        // Show wall frozen modal without re-rendering (which would reset timer display)
                        showWallFrozenModal = true;
                        
                        // Add modal to DOM without full re-render
                        const gameContainer = document.querySelector('.game-container');
                        if (gameContainer) {
                            const modalHtml = `
                                <div class="wall-frozen-modal">
                                    <div class="wall-frozen-content">
                                        <div class="wall-frozen-title">The Wall has frozen!</div>
                                        <button class="btn btn-primary" onclick="resolveWallAfterFrozen()" style="font-size: 1.25rem; padding: 1rem 2rem;">Resolve the Wall</button>
                                    </div>
                                </div>
                            `;
                            gameContainer.insertAdjacentHTML('beforeend', modalHtml);
                        }
                    }
                }
            }
        }

        function updateTilePositions() {
            // Calculate new positions for all tiles
            let positionIndex = 0;
            const tilePositions = new Map();
            
            // Assign positions: solved groups first (in order solved), then unsolved
            solvedGroups.forEach((group, groupIdx) => {
                group.items.forEach(itemText => {
                    const tileIndex = wallTiles.findIndex(t => t.text === itemText && t.solvedGroupIndex === groupIdx);
                    if (tileIndex !== -1) {
                        tilePositions.set(tileIndex, positionIndex);
                        positionIndex++;
                    }
                });
            });
            
            // Unsolved tiles get remaining positions
            wallTiles.forEach((tile, index) => {
                if (!tile.solved) {
                    tilePositions.set(index, positionIndex);
                    positionIndex++;
                }
            });
            
            // Update DOM elements with new positions
            wallTiles.forEach((tile, index) => {
                const element = document.querySelector(`[data-tile-id="${index}"]`);
                if (element) {
                    const pos = tilePositions.get(index);
                    const row = Math.floor(pos / 4);
                    const col = pos % 4;
                    
                    const topPx = row * 100 + row * 12;
                    const leftCalc = `calc(${col} * ((100% - 2.25rem) / 4 + 0.75rem))`;
                    
                    element.style.top = topPx + 'px';
                    element.style.left = leftCalc;
                    
                    // Update classes for solved tiles
                    if (tile.solved) {
                        element.classList.add('solved', 'group-' + tile.solvedGroupIndex);
                        element.classList.remove('selected');
                    }
                }
            });
        }

        function autoSolveLastGroup() {
            const wallData = gameData.round3[0];
            
            // Find the one unsolved group
            for (let groupIndex = 0; groupIndex < 4; groupIndex++) {
                const alreadySolved = solvedGroups.some(g => g.groupIndex === groupIndex);
                
                if (!alreadySolved) {
                    const groupTiles = [];
                    
                    wallTiles.forEach((tile, index) => {
                        if (tile.groupIndex === groupIndex && !tile.solved) {
                            tile.solved = true;
                            tile.solvedGroupIndex = solvedGroups.length;
                            groupTiles.push(tile.text);
                        }
                    });
                    
                    if (groupTiles.length > 0) {
                        solvedGroups.push({
                            items: groupTiles.sort(),
                            connection: wallData.groups[groupIndex].connection,
                            groupIndex: groupIndex,
                            solvedGroupIndex: solvedGroups.length
                        });
                        
                        // Award point for the last group
                        score += 1;
                        const scoreElement = document.querySelector('.score-value');
                        if (scoreElement) scoreElement.textContent = score;
                        
                        // Animate tiles to their positions
                        updateTilePositions();
                    }
                    break; // Only one group left
                }
            }
        }

        function endWallSolving() {
            wallPhase = 'guessing';
            render();
        }

        function autoSolveRemainingGroups() {
            const wallData = gameData.round3[0];
            
            // Find all unsolved groups and mark them
            for (let groupIndex = 0; groupIndex < 4; groupIndex++) {
                const alreadySolved = solvedGroups.some(g => g.groupIndex === groupIndex);
                
                if (!alreadySolved) {
                    const groupTiles = [];
                    
                    wallTiles.forEach((tile, index) => {
                        if (tile.groupIndex === groupIndex && !tile.solved) {
                            tile.solved = true;
                            tile.solvedGroupIndex = solvedGroups.length;
                            groupTiles.push(tile.text);
                        }
                    });
                    
                    if (groupTiles.length > 0) {
                        solvedGroups.push({
                            items: groupTiles.sort(),
                            connection: wallData.groups[groupIndex].connection,
                            groupIndex: groupIndex,
                            solvedGroupIndex: solvedGroups.length,
                            autoSolved: true
                        });
                    }
                }
            }
            
            // Update positions with animation instead of re-rendering
            updateTilePositions();
        }

        function guessConnection(groupIndex, correct) {
            if (correct) {
                score += 1;
            }
            
            // Clear all existing justRevealed flags to prevent re-animation
            connectionGuesses.forEach(guess => {
                if (guess && guess.justRevealed) {
                    guess.justRevealed = false;
                }
            });
            
            connectionGuesses[groupIndex] = {
                correct: correct,
                revealed: true,
                justRevealed: true // Flag for fade-in animation
            };
            
            // Check if all connections have been guessed
            const allGuessed = solvedGroups.every((_, idx) => connectionGuesses[idx]);
            
            // Check for bonus: all 4 groups found in time AND all 4 guessed correctly
            if (allGuessed) {
                const allFoundInTime = solvedGroups.every(g => !g.autoSolved);
                const allGuessedCorrect = connectionGuesses.every(g => g.correct);
                
                if (allFoundInTime && allGuessedCorrect) {
                    score += 2; // Bonus points
                }
            }
            
            render();
            
            // Remove justRevealed flag after animation completes
            setTimeout(() => {
                if (connectionGuesses[groupIndex]) {
                    connectionGuesses[groupIndex].justRevealed = false;
                }
            }, 1000);
        }

        function selectQuestion(questionIndex) {
            const questionKey = `r${currentRound}q${questionIndex}`;
            if (completedQuestions.includes(questionKey)) return;
            currentQuestion = questionIndex;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerStoppedOnClue = null;
            resetTimer();
            timerDuration = 60000; // 60 seconds for rounds 1 and 2
            view = 'clues';
            render();
        }

        function revealClue(index) {
            const isSequence = currentRound === 1;
            
            // Only allow advancing to the next clue
            if (index === cluesRevealed) {
                // For sequence round, check if we're trying to reveal clue 4 before timer is stopped
                if (isSequence && index === 3 && !timerStopped) {
                    return; // Don't reveal the 4th clue until timer is stopped
                }
                
                cluesRevealed++;
                
                // Start timer only if it hasn't been stopped and we're not on the 4th clue
                if (!timerStopped && cluesRevealed < 4) {
                    startTimer();
                }
                
                render();
            }
        }

        function backToRounds() {
            view = 'rounds';
            currentRound = null;
            currentQuestion = null;
            resetTimer();
            render();
        }

        function backToQuestions() {
            view = 'questions';
            currentQuestion = null;
            cluesRevealed = 0;
            answerRevealed = false;
            timerStopped = false;
            timerStoppedOnClue = null;
            resetTimer();
            render();
        }

        function renderRoundSelector() {
            return `
                <div class="round-selector">
                    <button class="round-btn" onclick="selectRound(0)">
                        <div class="round-title">Round 1</div>
                        <div>Connections</div>
                    </button>
                    <button class="round-btn" onclick="selectRound(1)">
                        <div class="round-title">Round 2</div>
                        <div>Sequences</div>
                    </button>
                    <button class="round-btn" onclick="selectRound(2)">
                        <div class="round-title">Round 3</div>
                        <div>Connecting Wall</div>
                    </button>
                </div>
            `;
        }

        function renderQuestionSelector() {
            const questions = currentRound === 0 ? gameData.round1 : gameData.round2;
            let html = '<button class="back-btn" onclick="backToRounds()">‚Üê Back to Rounds</button>';
            html += '<div class="question-grid">';
            for (let i = 0; i < questions.length; i++) {
                const questionKey = `r${currentRound}q${i}`;
                const completed = completedQuestions.includes(questionKey);
                html += `<button class="question-btn ${completed ? 'completed' : ''}" onclick="selectQuestion(${i})">Q${i + 1}</button>`;
            }
            html += '</div>';
            return html;
        }

        function renderClues() {
            const isSequence = currentRound === 1;
            const question = isSequence ? gameData.round2[currentQuestion] : gameData.round1[currentQuestion];
            const pointsValues = question.points;
            
            // Always render button but hide with visibility when timer is active
            let html = '';
            const hideButton = cluesRevealed > 0 ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn" onclick="backToQuestions()"${hideButton}>‚Üê Back to Questions</button>`;
            html += '<div class="clue-container"><div class="clue-grid">';
            
            for (let i = 0; i < 4; i++) {
                html += '<div class="clue-wrapper">';
                
                // Determine which clue should show the timer/points
                let showTimerOnThisClue;
                if (timerStopped && timerStoppedOnClue !== null) {
                    // If timer is stopped, show it on the clue where it was stopped
                    showTimerOnThisClue = (i === timerStoppedOnClue);
                } else {
                    // Otherwise, show it on the currently active clue (before it's revealed)
                    // For sequences, don't show timer/points on 4th clue
                    showTimerOnThisClue = isSequence ? (i === cluesRevealed - 1 && cluesRevealed > 0 && i < 3) : (i === cluesRevealed - 1 && cluesRevealed > 0);
                }
                
                if (showTimerOnThisClue) {
                    html += `<div class="points-label">${pointsValues[i]} Point${pointsValues[i] !== 1 ? 's' : ''}</div>`;
                    html += `<div class="timer-bar-container"><div id="timerBar" class="timer-bar" style="width: 100%;"></div><div id="timerText" class="timer-text">60s</div></div>`;
                } else {
                    html += '<div class="timer-spacer"></div>';
                }
                
                const revealed = i < cluesRevealed;
                
                // For sequences, 4th clue can only be revealed after timer is stopped
                const canReveal = isSequence ? (i < 3 || timerStopped) : true;
                const clueText = revealed ? question.clues[i] : '';
                const classes = 'clue-btn' + (revealed ? ' revealed' : '');
                
                // Only make the NEXT unrevealed clue clickable
                const onclick = (i === cluesRevealed && canReveal) ? `onclick="revealClue(${i})"` : '';
                
                html += `<button class="${classes}" ${onclick}>${clueText}</button>`;
                html += '</div>';
            }
            html += '</div>'; // Close grid
            
            // ANSWER BOX - in same container as clues
            const answerText = isSequence ? question.answer : question.connection;
            const subtitle = isSequence ? question.sequence : '';
            html += '<div class="answer-box">';
            if (answerRevealed) {
                html += `<div><div style="font-size: 0.875rem; margin-bottom: 0.5rem;">${isSequence ? 'Answer:' : 'Connection:'}</div>`;
                html += `<div style="font-size: 1.25rem; font-weight: bold;">${answerText}</div>`;
                if (subtitle) html += `<div style="font-size: 0.875rem; margin-top: 0.5rem; opacity: 0.8;">${subtitle}</div>`;
                html += '</div>';
            }
            html += '</div>'; // Close answer box
            html += '</div>'; // Close clue container
            
            // BUTTONS CONTAINER - separate container for correct/incorrect/continue with fixed height
            html += '<div class="buttons-container">';
            if (timerStopped && !answerRevealed) {
                html += '<div class="button-row">';
                html += '<button class="btn btn-correct" onclick="markCorrect()">Correct</button>';
                html += '<button class="btn btn-incorrect" onclick="markIncorrect()">Incorrect</button>';
                html += '</div>';
            }
            if (answerRevealed) {
                html += '<button class="btn btn-primary" onclick="completeQuestion()">Continue</button>';
            }
            html += '</div>'; // Close buttons container
            
            return html;
        }

        function renderWall() {
            const remainingGroups = 4 - solvedGroups.length;
            const showLives = remainingGroups === 2 && wallPhase === 'solving' && wallTimerReady;
            
            let html = '<div class="wall-header">';
            // Always render button but hide with visibility when timer has started
            const hideButton = wallTimerReady ? ' style="visibility: hidden;"' : '';
            html += `<button class="back-btn" onclick="backToRounds()"${hideButton}>‚Üê Back to Rounds</button>`;
            if (showLives) {
                html += `<div class="lives-display">Lives: ${'‚ù§Ô∏è'.repeat(wallLives)}${'üñ§'.repeat(3 - wallLives)}</div>`;
            }
            html += '</div>';
            
            // Render the wall grid with tiles
            html += '<div class="wall-grid" style="position: relative; min-height: 440px;">';
            
            // Calculate positions for all 16 tiles
            let positionIndex = 0;
            const tilePositions = new Map();
            
            // Assign positions: solved groups first (in order solved), then unsolved
            solvedGroups.forEach((group, groupIdx) => {
                group.items.forEach(itemText => {
                    const tileIndex = wallTiles.findIndex(t => t.text === itemText && t.solvedGroupIndex === groupIdx);
                    if (tileIndex !== -1) {
                        tilePositions.set(tileIndex, positionIndex);
                        positionIndex++;
                    }
                });
            });
            
            // Unsolved tiles get remaining positions
            wallTiles.forEach((tile, index) => {
                if (!tile.solved) {
                    tilePositions.set(index, positionIndex);
                    positionIndex++;
                }
            });
            
            // Render each tile with calculated position
            wallTiles.forEach((tile, index) => {
                const pos = tilePositions.get(index);
                const row = Math.floor(pos / 4);
                const col = pos % 4;
                
                // Calculate pixel positions (accounting for gaps)
                const tileWidth = 'calc((100% - 2.25rem) / 4)';
                const gapSize = 0.75; // rem
                const topPx = row * 100 + row * 12; // 100px height + 0.75rem gap (approx 12px)
                const leftCalc = `calc(${col} * ((100% - 2.25rem) / 4 + ${gapSize}rem))`;
                
                let classes = 'wall-tile';
                const isSelected = selectedTiles.includes(index);
                
                // Add text-up class if this tile's group has a revealed connection
                const hasOverlay = tile.solved && wallPhase === 'guessing' && 
                                   connectionGuesses[tile.solvedGroupIndex] && 
                                   connectionGuesses[tile.solvedGroupIndex].revealed;
                if (hasOverlay) {
                    classes += ' text-up';
                }
                
                // Hide text until timer starts
                if (!wallTimerReady) {
                    classes += ' hidden-text';
                }
                
                if (tile.solved) {
                    classes += ' solved group-' + tile.solvedGroupIndex;
                } else if (isSelected) {
                    classes += ' selected';
                } else if (wallPhase !== 'solving') {
                    classes += ' locked';
                }
                
                const onclick = (!tile.solved && wallPhase === 'solving' && wallTimerReady) ? `onclick="toggleTile(${index})"` : '';
                const style = `top: ${topPx}px; left: ${leftCalc}; width: ${tileWidth};`;
                
                html += `<button class="${classes}" ${onclick} style="${style}" data-tile-id="${index}">${tile.text}</button>`;
            });
            
            // In guessing phase, add overlays and buttons on the actual grid
            if (wallPhase === 'guessing') {
                solvedGroups.forEach((group, idx) => {
                    const row = idx;
                    const topPx = row * 100 + row * 12;
                    
                    // Connection overlay (appears in lower half of the row)
                    if (connectionGuesses[idx] && connectionGuesses[idx].revealed) {
                        const overlayTop = topPx + 50; // Start at middle of tile
                        const fadeInClass = connectionGuesses[idx].justRevealed ? ' fade-in' : '';
                        const displayStyle = connectionGuesses[idx].justRevealed ? '' : ' opacity: 1;';
                        html += `<div class="connection-display${fadeInClass}" style="top: ${overlayTop}px;${displayStyle}">${group.connection}</div>`;
                    }
                    
                    // Guess buttons (to the right of the row, side by side)
                    if (!connectionGuesses[idx]) {
                        // Buttons side by side, centered vertically in the row
                        const buttonsTop = topPx + 27; // Center in 100px row (50px - 45px/2)
                        html += `<div style="position: absolute; right: -120px; top: ${buttonsTop}px; display: flex; gap: 0.5rem;">`;
                        html += `<button class="guess-btn correct" onclick="guessConnection(${idx}, true)">‚úì</button>`;
                        html += `<button class="guess-btn incorrect" onclick="guessConnection(${idx}, false)">‚úó</button>`;
                        html += '</div>';
                    }
                });
            }
            
            html += '</div>'; // Close wall-grid
            
            // Show timer or start button during solving phase
            if (wallPhase === 'solving') {
                html += '<div class="wall-timer-container">';
                if (!wallTimerReady) {
                    // Show Start Timer button
                    html += '<div style="text-align: center; padding: 1rem;">';
                    html += '<button class="btn btn-primary" onclick="startWallTimer()" style="font-size: 1.25rem; padding: 1rem 2rem;">Start Timer</button>';
                    html += '</div>';
                } else {
                    // Show timer
                    html += '<div class="timer-bar-container"><div id="timerBar" class="timer-bar" style="width: 100%;"></div><div id="timerText" class="timer-text">180s</div></div>';
                }
                html += '</div>';
            }
            
            // Continue button after all guessed
            if (wallPhase === 'guessing') {
                const allGuessed = solvedGroups.every((_, idx) => connectionGuesses[idx]);
                if (allGuessed) {
                    html += '<div style="margin-top: 1.5rem; text-align: center;">';
                    html += '<button class="btn btn-primary" onclick="backToRounds()">Continue</button>';
                    html += '</div>';
                }
            }
            
            // Time up modal
            if (showTimeUpModal) {
                html += '<div class="time-up-modal">';
                html += '<div class="time-up-content">';
                html += '<div class="time-up-title">Time is Up</div>';
                html += '<button class="btn btn-primary" onclick="resolveWallAfterTimeout()" style="font-size: 1.25rem; padding: 1rem 2rem;">Resolve the Wall</button>';
                html += '</div>';
                html += '</div>';
            }
            
            // Wall frozen modal
            if (showWallFrozenModal) {
                html += '<div class="wall-frozen-modal">';
                html += '<div class="wall-frozen-content">';
                html += '<div class="wall-frozen-title">The Wall has frozen!</div>';
                html += '<button class="btn btn-primary" onclick="resolveWallAfterFrozen()" style="font-size: 1.25rem; padding: 1rem 2rem;">Resolve the Wall</button>';
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        function render() {
            const container = document.getElementById('gameContainer');
            let content = '';
            if (view === 'rounds') content = renderRoundSelector();
            else if (view === 'questions') content = renderQuestionSelector();
            else if (view === 'clues') content = renderClues();
            else if (view === 'wall') content = renderWall();
            
            container.innerHTML = `
                <div class="game-container">
                    <div class="header-card">
                        <h1 class="header-title">Only Connect</h1>
                        <div class="score-box">
                            <div class="score-label">Player Name</div>
                            <div class="score-value">${score}</div>
                        </div>
                    </div>
                    ${content}
                </div>
            `;
            if (view === 'clues' && timerStartTime !== null) updateTimer();
            if (view === 'wall' && wallPhase === 'solving' && timerStartTime !== null) updateTimer();
        }

        render();
    </script>
</body>
</html>